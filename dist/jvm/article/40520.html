<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入拆解 Java 虚拟机</title>
    <meta name="description" content="Deep Dismantling of Java Virtual Machines">
    <link rel="icon" href="/jvm/logo.png">
    
    <link rel="preload" href="/jvm/assets/css/0.styles.80faf303.css" as="style"><link rel="preload" href="/jvm/assets/js/app.d44a01f6.js" as="script"><link rel="preload" href="/jvm/assets/js/35.0b788f34.js" as="script"><link rel="prefetch" href="/jvm/assets/js/10.b4a8a827.js"><link rel="prefetch" href="/jvm/assets/js/11.bfe83943.js"><link rel="prefetch" href="/jvm/assets/js/12.b25aa468.js"><link rel="prefetch" href="/jvm/assets/js/13.f35b4b14.js"><link rel="prefetch" href="/jvm/assets/js/14.d49650d6.js"><link rel="prefetch" href="/jvm/assets/js/15.5a71ef71.js"><link rel="prefetch" href="/jvm/assets/js/16.39144d7d.js"><link rel="prefetch" href="/jvm/assets/js/17.1a61435a.js"><link rel="prefetch" href="/jvm/assets/js/18.95b1bee1.js"><link rel="prefetch" href="/jvm/assets/js/19.1dd19d7a.js"><link rel="prefetch" href="/jvm/assets/js/2.d2d3b164.js"><link rel="prefetch" href="/jvm/assets/js/20.5dfbcdd0.js"><link rel="prefetch" href="/jvm/assets/js/21.fce787bf.js"><link rel="prefetch" href="/jvm/assets/js/22.063ac2ae.js"><link rel="prefetch" href="/jvm/assets/js/23.9db307ef.js"><link rel="prefetch" href="/jvm/assets/js/24.3009a915.js"><link rel="prefetch" href="/jvm/assets/js/25.648c2c86.js"><link rel="prefetch" href="/jvm/assets/js/26.33fc6899.js"><link rel="prefetch" href="/jvm/assets/js/27.cb22d900.js"><link rel="prefetch" href="/jvm/assets/js/28.634ebc75.js"><link rel="prefetch" href="/jvm/assets/js/29.f411aaad.js"><link rel="prefetch" href="/jvm/assets/js/3.f64f10dc.js"><link rel="prefetch" href="/jvm/assets/js/30.60b08124.js"><link rel="prefetch" href="/jvm/assets/js/31.214f3fb7.js"><link rel="prefetch" href="/jvm/assets/js/32.3b4d182b.js"><link rel="prefetch" href="/jvm/assets/js/33.bd3d415a.js"><link rel="prefetch" href="/jvm/assets/js/34.3d46a13b.js"><link rel="prefetch" href="/jvm/assets/js/36.92608b69.js"><link rel="prefetch" href="/jvm/assets/js/37.d2ff4488.js"><link rel="prefetch" href="/jvm/assets/js/38.88385b69.js"><link rel="prefetch" href="/jvm/assets/js/39.6ebedb05.js"><link rel="prefetch" href="/jvm/assets/js/4.cecc0b55.js"><link rel="prefetch" href="/jvm/assets/js/40.c04c4d3f.js"><link rel="prefetch" href="/jvm/assets/js/41.400ac52b.js"><link rel="prefetch" href="/jvm/assets/js/42.1b347f87.js"><link rel="prefetch" href="/jvm/assets/js/43.49db281a.js"><link rel="prefetch" href="/jvm/assets/js/5.7f9cb687.js"><link rel="prefetch" href="/jvm/assets/js/6.d3241020.js"><link rel="prefetch" href="/jvm/assets/js/7.f5fe3fc4.js"><link rel="prefetch" href="/jvm/assets/js/8.61fdea72.js"><link rel="prefetch" href="/jvm/assets/js/9.33c162e9.js">
    <link rel="stylesheet" href="/jvm/assets/css/0.styles.80faf303.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jvm/" class="home-link router-link-active"><!----> <span class="site-name">深入拆解 Java 虚拟机</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jvm/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他专栏</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/frontend/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  重学前端
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/ds/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  数据结构与算法之美
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/netprotocol/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  趣谈网络协议
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/air/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  左耳听风
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/blockchain/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入浅出区块链
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/webyck/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端面试之道
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/webinter/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Web 前端面试指南与高频考题解析
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jvm/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他专栏</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/frontend/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  重学前端
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/ds/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  数据结构与算法之美
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/netprotocol/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  趣谈网络协议
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/air/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  左耳听风
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/blockchain/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入浅出区块链
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/webyck/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端面试之道
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/webinter/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Web 前端面试指南与高频考题解析
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/jvm/article/11074.html" class="sidebar-link">开篇词 | 为什么我们要学习Java虚拟机？</a></li><li><a href="/jvm/article/11289.html" class="sidebar-link">01 | Java代码是怎么运行的？</a></li><li><a href="/jvm/article/11503.html" class="sidebar-link">02 | Java的基本类型</a></li><li><a href="/jvm/article/11523.html" class="sidebar-link">03 | Java虚拟机是如何加载Java类的?</a></li><li><a href="/jvm/article/11539.html" class="sidebar-link">04 | JVM是如何执行方法调用的？（上）</a></li><li><a href="/jvm/article/12098.html" class="sidebar-link">05 | JVM是如何执行方法调用的？（下）</a></li><li><a href="/jvm/article/12134.html" class="sidebar-link">06 | JVM是如何处理异常的？</a></li><li><a href="/jvm/article/12192.html" class="sidebar-link">07 | JVM是如何实现反射的？</a></li><li><a href="/jvm/article/12423.html" class="sidebar-link">【工具篇】 常用工具介绍</a></li><li><a href="/jvm/article/12564.html" class="sidebar-link">08 | JVM是怎么实现invokedynamic的？（上）</a></li><li><a href="/jvm/article/12574.html" class="sidebar-link">09 | JVM是怎么实现invokedynamic的？（下）</a></li><li><a href="/jvm/article/13081.html" class="sidebar-link">10 | Java对象的内存布局</a></li><li><a href="/jvm/article/13091.html" class="sidebar-link">11 | 垃圾回收（上）</a></li><li><a href="/jvm/article/13137.html" class="sidebar-link">12 | 垃圾回收（下）</a></li><li><a href="/jvm/article/13484.html" class="sidebar-link">13 | Java内存模型</a></li><li><a href="/jvm/article/13530.html" class="sidebar-link">14 | Java虚拟机是怎么实现synchronized的？</a></li><li><a href="/jvm/article/13781.html" class="sidebar-link">15 | Java语法糖与Java编译器</a></li><li><a href="/jvm/article/14061.html" class="sidebar-link">16 | 即时编译（上）</a></li><li><a href="/jvm/article/14070.html" class="sidebar-link">17 | 即时编译（下）</a></li><li><a href="/jvm/article/14270.html" class="sidebar-link">18 | 即时编译器的中间表达形式</a></li><li><a href="/jvm/article/14575.html" class="sidebar-link">20 | 方法内联（上）</a></li><li><a href="/jvm/article/14652.html" class="sidebar-link">21 | 方法内联（下）</a></li><li><a href="/jvm/article/14794.html" class="sidebar-link">19 |  Java字节码（基础篇）</a></li><li><a href="/jvm/article/18046.html" class="sidebar-link">22 | HotSpot虚拟机的intrinsic</a></li><li><a href="/jvm/article/18048.html" class="sidebar-link">23 | 逃逸分析</a></li><li><a href="/jvm/article/39683.html" class="sidebar-link">24 | 字段访问相关优化</a></li><li><a href="/jvm/article/39814.html" class="sidebar-link">25 | 循环优化</a></li><li><a href="/jvm/article/39838.html" class="sidebar-link">26 | 向量化</a></li><li><a href="/jvm/article/40189.html" class="sidebar-link">27 | 注解处理器</a></li><li><a href="/jvm/article/40275.html" class="sidebar-link">28 | 基准测试框架JMH（上）</a></li><li><a href="/jvm/article/40281.html" class="sidebar-link">29 | 基准测试框架JMH（下）</a></li><li><a href="/jvm/article/40520.html" class="active sidebar-link">30 | Java虚拟机的监控及诊断工具（命令行篇）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jvm/article/40520.html#jps" class="sidebar-link">jps</a></li><li class="sidebar-sub-header"><a href="/jvm/article/40520.html#jstat" class="sidebar-link">jstat</a></li><li class="sidebar-sub-header"><a href="/jvm/article/40520.html#jmap" class="sidebar-link">jmap</a></li><li class="sidebar-sub-header"><a href="/jvm/article/40520.html#jinfo" class="sidebar-link">jinfo</a></li><li class="sidebar-sub-header"><a href="/jvm/article/40520.html#jstack" class="sidebar-link">jstack</a></li><li class="sidebar-sub-header"><a href="/jvm/article/40520.html#jcmd" class="sidebar-link">jcmd</a></li><li class="sidebar-sub-header"><a href="/jvm/article/40520.html#总结与实践" class="sidebar-link">总结与实践</a></li></ul></li><li><a href="/jvm/article/40821.html" class="sidebar-link">31 | Java虚拟机的监控及诊断工具（GUI篇）</a></li><li><a href="/jvm/article/40839.html" class="sidebar-link">32 | JNI的运行机制</a></li><li><a href="/jvm/article/41186.html" class="sidebar-link">33 | Java Agent与字节码注入</a></li><li><a href="/jvm/article/41245.html" class="sidebar-link">34 | Graal：用Java编译Java</a></li><li><a href="/jvm/article/41347.html" class="sidebar-link">35 | Truffle：语言实现框架</a></li><li><a href="/jvm/article/41582.html" class="sidebar-link">36 | SubstrateVM：AOT编译框架</a></li><li><a href="/jvm/article/41800.html" class="sidebar-link">尾声 | 道阻且长，努力加餐</a></li></ul> </div> <div class="page"> <div class="content"><p>今天，我们来一起了解一下JDK中用于监控及诊断工具。本篇中我将使用刚刚发布的Java 11版本的工具进行示范。</p> <h2 id="jps"><a href="#jps" aria-hidden="true" class="header-anchor">#</a> jps</h2> <p>你可能用过<code>ps</code>命令，打印所有正在运行的进程的相关信息。JDK中的<code>jps</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jps.html" target="_blank" rel="noopener noreferrer">帮助文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）沿用了同样的概念：它将打印所有正在运行的Java进程的相关信息。</p> <p>在默认情况下，<code>jps</code>的输出信息包括Java进程的进程ID以及主类名。我们还可以通过追加参数，来打印额外的信息。例如，<code>-l</code>将打印模块名以及包名；<code>-v</code>将打印传递给Java虚拟机的参数（如<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>）；<code>-m</code>将打印传递给主类的参数。</p> <p>具体的示例如下所示：</p> <pre><code>$ jps -mlv
18331 org.example.Foo Hello World
18332 jdk.jcmd/sun.tools.jps.Jps -mlv -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home -Xms8m -Djdk.module.main=jdk.jcmd
</code></pre> <p>需要注意的是，如果某Java进程关闭了默认开启的<code>UsePerfData</code>参数（即使用参数<code>-XX:-UsePerfData</code>），那么<code>jps</code>命令（以及下面介绍的<code>jstat</code>）将无法探知该Java进程。</p> <p>当获得Java进程的进程ID之后，我们便可以调用接下来介绍的各项监控及诊断工具了。</p> <h2 id="jstat"><a href="#jstat" aria-hidden="true" class="header-anchor">#</a> jstat</h2> <p><code>jstat</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html" target="_blank" rel="noopener noreferrer">帮助文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）可用来打印目标Java进程的性能数据。它包括多条子命令，如下所示：</p> <pre><code>$ jstat -options
-class
-compiler
-gc
-gccapacity
-gccause
-gcmetacapacity
-gcnew
-gcnewcapacity
-gcold
-gcoldcapacity
-gcutil
-printcompilation
</code></pre> <p>在这些子命令中，<code>-class</code>将打印类加载相关的数据，<code>-compiler</code>和<code>-printcompilation</code>将打印即时编译相关的数据。剩下的都是以<code>-gc</code>为前缀的子命令，它们将打印垃圾回收相关的数据。</p> <p>默认情况下，<code>jstat</code>只会打印一次性能数据。我们可以将它配置为每隔一段时间打印一次，直至目标Java进程终止，或者达到我们所配置的最大打印次数。具体示例如下所示：</p> <pre><code># Usage: jstat -outputOptions [-t] [-hlines] VMID [interval [count]]
$ jstat -gc 22126 1s 4
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   
17472,0 17472,0  0,0    0,0   139904,0 47146,4   349568,0   21321,0   30020,0 28001,8 4864,0 4673,4     22    0,080   3      0,270   0      0,000    0,350
17472,0 17472,0 420,6   0,0   139904,0 11178,4   349568,0   21321,0   30020,0 28090,1 4864,0 4674,2     28    0,084   3      0,270   0      0,000    0,354
17472,0 17472,0  0,0   403,9  139904,0 139538,4  349568,0   21323,4   30020,0 28137,2 4864,0 4674,2     34    0,088   4      0,359   0      0,000    0,446
17472,0 17472,0  0,0    0,0   139904,0   0,0     349568,0   21326,1   30020,0 28093,6 4864,0 4673,4     38    0,091   5      0,445   0      0,000    0,536
</code></pre> <blockquote><p>当监控本地环境的Java进程时，VMID可以简单理解为PID。如果需要监控远程环境的Java进程，你可以参考jstat的帮助文档。</p></blockquote> <p>在上面这个示例中，22126进程是一个使用了CMS垃圾回收器的Java进程。我们利用<code>jstat</code>的<code>-gc</code>子命令，来打印该进程垃圾回收相关的数据。命令最后的<code>1s 4</code>表示每隔1秒打印一次，共打印4次。</p> <p>在<code>-gc</code>子命令的输出中，前四列分别为两个Survivor区的容量（Capacity）和已使用量（Utility）。我们可以看到，这两个Survivor区的容量相等，而且始终有一个Survivor区的内存使用量为0。</p> <p>当使用默认的G1 GC时，输出结果则有另一些特征：</p> <pre><code>$ jstat -gc 22208 1s
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   
0,0   16384,0  0,0   16384,0 210944,0 192512,0  133120,0    5332,5   28848,0 26886,4 4864,0 4620,5     19    0,067   1      0,016   2      0,002    0,084
0,0   16384,0  0,0   16384,0 210944,0 83968,0   133120,0    5749,9   29104,0 27132,8 4864,0 4621,0     21    0,078   1      0,016   2      0,002    0,095
0,0    0,0    0,0    0,0   71680,0  18432,0   45056,0    20285,1   29872,0 27952,4 4864,0 4671,6     23    0,089   2      0,063   2      0,002    0,153
0,0   2048,0  0,0   2048,0 69632,0  28672,0   45056,0    18608,1   30128,0 28030,4 4864,0 4672,4     32    0,093   2      0,063   2      0,002    0,158
...
</code></pre> <p>在上面这个示例中，<code>jstat</code>每隔1s便会打印垃圾回收的信息，并且不断重复下去。</p> <p>你可能已经留意到，<code>S0C</code>和<code>S0U</code>始终为0，而且另一个Survivor区的容量（S1C）可能会下降至0。</p> <p>这是因为，当使用G1 GC时，Java虚拟机不再设置Eden区、Survivor区，老年代区的内存边界，而是将堆划分为若干个等长内存区域。</p> <p>每个内存区域都可以作为Eden区、Survivor区以及老年代区中的任一种，并且可以在不同区域类型之间来回切换。（<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener noreferrer">参考链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p> <p>换句话说，逻辑上我们只有一个Survivor区。当需要迁移Survivor区中的数据时（即Copying GC），我们只需另外申请一个或多个内存区域，作为新的Survivor区。</p> <p>因此，Java虚拟机决定在使用G1 GC时，将所有Survivor内存区域的总容量以及已使用量存放至S1C和S1U中，而S0C和S0U则被设置为0。</p> <p>当发生垃圾回收时，Java虚拟机可能出现Survivor内存区域内的对象<strong>全</strong>被回收或晋升的现象。</p> <p>在这种情况下，Java虚拟机会将这块内存区域回收，并标记为可分配的状态。这样子做的结果是，堆中可能完全没有Survivor内存区域，因而相应的S1C和S1U将会是0。</p> <p><code>jstat</code>还有一个非常有用的参数<code>-t</code>，它将在每行数据之前打印目标Java进程的启动时间。例如，在下面这个示例中，第一列代表该Java进程已经启动了10.7秒。</p> <pre><code>$ jstat -gc -t 22407
Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   
           10,7  0,0    0,0    0,0    0,0   55296,0  45056,0   34816,0    20267,8   30128,0 27975,3 4864,0 4671,6     33    0,086   3      0,111   2      0,001    0,198
</code></pre> <p>我们可以比较Java进程的启动时间以及总GC时间（GCT列），或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例。</p> <p>如果该比例超过20%，则说明目前堆的压力较大；如果该比例超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常。</p> <p><code>jstat</code>还可以用来判断是否出现内存泄漏。在长时间运行的Java程序中，我们可以运行<code>jstat</code>命令连续获取多行性能数据，并取这几行数据中OU列（即已占用的老年代内存）的最小值。</p> <p>然后，我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上涨趋势，则说明该Java程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p> <blockquote><p>上面没有涉及的列（或者其他子命令的输出），你可以查阅帮助文档了解具体含义。至于文档中漏掉的CGC和CGCT，它们分别代表并发GC Stop-The-World的次数和时间。</p></blockquote> <h2 id="jmap"><a href="#jmap" aria-hidden="true" class="header-anchor">#</a> jmap</h2> <p>在这种情况下，我们便可以请<code>jmap</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html" target="_blank" rel="noopener noreferrer">帮助文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）出马，分析Java虚拟机堆中的对象。</p> <p><code>jmap</code>同样包括多条子命令。</p> <ol><li><code>-clstats</code>，该子命令将打印被加载类的信息。</li> <li><code>-finalizerinfo</code>，该子命令将打印所有待finalize的对象。</li> <li><code>-histo</code>，该子命令将统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，<code>-histo:live</code>只统计堆中的存活对象。</li> <li><code>-dump</code>，该子命令将导出Java虚拟机堆的快照。同样，<code>-dump:live</code>只保存堆中的存活对象。</li></ol> <p>我们通常会利用<code>jmap -dump:live,format=b,file=filename.bin</code>命令，将堆中所有存活对象导出至一个文件之中。</p> <p>这里<code>format=b</code>将使<code>jmap</code>导出与<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr008.html" target="_blank" rel="noopener noreferrer">hprof<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（在Java 9中已被移除）、<code>-XX:+HeapDumpAfterFullGC</code>、<code>-XX:+HeapDumpOnOutOfMemoryError</code>格式一致的文件。这种格式的文件可以被其他GUI工具查看，具体我会在下一篇中进行演示。</p> <p>下面我贴了一段<code>-histo</code>子命令的输出：</p> <pre><code>$ jmap -histo 22574
 num     #instances         #bytes  class name (module)
-------------------------------------------------------
   1:        500004       20000160  org.python.core.PyComplex
   2:        570866       18267712  org.python.core.PyFloat
   3:        360295       18027024  [B (java.base@11)
   4:        339394       11429680  [Lorg.python.core.PyObject;
   5:        308637       11194264  [Ljava.lang.Object; (java.base@11)
   6:        301378        9291664  [I (java.base@11)
   7:        225103        9004120  java.math.BigInteger (java.base@11)
   8:        507362        8117792  org.python.core.PySequence$1
   9:        285009        6840216  org.python.core.PyLong
  10:        282908        6789792  java.lang.String (java.base@11)
  ...
2281:             1             16  traceback$py
2282:             1             16  unicodedata$py
Total       5151277      167944400
</code></pre> <p>由于<code>jmap</code>将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，<code>jmap</code>需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。</p> <p>也就是说，由<code>jmap</code>导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么<code>:live</code>选项将无法探知到这些对象。</p> <p>另外，如果某个线程长时间无法跑到安全点，<code>jmap</code>将一直等下去。上一小节的<code>jstat</code>则不同。这是因为垃圾回收器会主动将<code>jstat</code>所需要的摘要数据保存至固定位置之中，而<code>jstat</code>只需直接读取即可。</p> <p>关于这种长时间等待的情况，你可以通过下面这段程序来复现：</p> <pre><code>// 暂停时间较长，约为二三十秒，可酌情调整。
// CTRL+C的SIGINT信号无法停止，需要SIGKILL。
static double sum = 0;

public static void main(String[] args) {
  for (int i = 0; i &lt; 0x77777777; i++) { // counted loop
    sum += Math.log(i); // Math.log is an intrinsic
  }
}
</code></pre> <p><code>jmap</code>（以及接下来的<code>jinfo</code>、<code>jstack</code>和<code>jcmd</code>）依赖于Java虚拟机的<a href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.attach/com/sun/tools/attach/package-summary.html" target="_blank" rel="noopener noreferrer">Attach API<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，因此只能监控本地Java进程。</p> <p>一旦开启Java虚拟机参数<code>DisableAttachMechanism</code>（即使用参数<code>-XX:+DisableAttachMechanism</code>），基于Attach API的命令将无法执行。反过来说，如果你不想被其他进程监控，那么你需要开启该参数。</p> <h2 id="jinfo"><a href="#jinfo" aria-hidden="true" class="header-anchor">#</a> jinfo</h2> <p><code>jinfo</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html" target="_blank" rel="noopener noreferrer">帮助文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）可用来查看目标Java进程的参数，如传递给Java虚拟机的<code>-X</code>（即输出中的jvm_args）、<code>-XX</code>参数（即输出中的VM Flags），以及可在Java层面通过<code>System.getProperty</code>获取的<code>-D</code>参数（即输出中的System Properties）。</p> <p>具体的示例如下所示：</p> <pre><code>$ jinfo 31185
Java System Properties:

gopherProxySet=false
awt.toolkit=sun.lwawt.macosx.LWCToolkit
java.specification.version=11
sun.cpu.isalist=
sun.jnu.encoding=UTF-8
...

VM Flags:
-XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=2097152 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=536870912 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=5152702464 -XX:MinHeapDeltaBytes=2097152 -XX:NonNMethodCodeHeapSize=5835340 -XX:NonProfiledCodeHeapSize=122911450 -XX:ProfiledCodeHeapSize=122911450 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC

VM Arguments:
jvm_args: -Xlog:gc -Xmx1024m
java_command: org.example.Foo
java_class_path (initial): .
Launcher Type: SUN_STANDARD
</code></pre> <p><code>jinfo</code>还可以用来修改目标Java进程的“manageable”虚拟机参数。</p> <p>举个例子，我们可以使用<code>jinfo -flag +HeapDumpAfterFullGC &lt;PID&gt;</code>命令，开启<code>&lt;PID&gt;</code>所指定的Java进程的<code>HeapDumpAfterFullGC</code>参数。</p> <p>你可以通过下述命令查看其他&quot;manageable&quot;虚拟机参数：</p> <pre><code>$ java -XX:+PrintFlagsFinal -version | grep manageable   
     intx CMSAbortablePrecleanWaitMillis           = 100                                    {manageable} {default}
     intx CMSTriggerInterval                       = -1                                     {manageable} {default}
     intx CMSWaitDuration                          = 2000                                   {manageable} {default}
     bool HeapDumpAfterFullGC                      = false                                  {manageable} {default}
     bool HeapDumpBeforeFullGC                     = false                                  {manageable} {default}
     bool HeapDumpOnOutOfMemoryError               = false                                  {manageable} {default}
    ccstr HeapDumpPath                             =                                        {manageable} {default}
    uintx MaxHeapFreeRatio                         = 70                                     {manageable} {default}
    uintx MinHeapFreeRatio                         = 40                                     {manageable} {default}
     bool PrintClassHistogram                      = false                                  {manageable} {default}
     bool PrintConcurrentLocks                     = false                                  {manageable} {default}
java version &quot;11&quot; 2018-09-25
Java(TM) SE Runtime Environment 18.9 (build 11+28)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)
</code></pre> <h2 id="jstack"><a href="#jstack" aria-hidden="true" class="header-anchor">#</a> jstack</h2> <p><code>jstack</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html" target="_blank" rel="noopener noreferrer">帮助文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）可以用来打印目标Java进程中各个线程的栈轨迹，以及这些线程所持有的锁。</p> <p><code>jstack</code>的其中一个应用场景便是死锁检测。这里我用<code>jstack</code>获取一个已经死锁了的Java程序的栈信息。具体输出如下所示：</p> <pre><code>$ jstack 31634
...

&quot;Thread-0&quot; #12 prio=5 os_prio=31 cpu=1.32ms elapsed=34.24s tid=0x00007fb08601c800 nid=0x5d03 waiting for monitor entry  [0x000070000bc7e000]
   java.lang.Thread.State: BLOCKED (on object monitor)
 at DeadLock.foo(DeadLock.java:18)
 - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)
 - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)
 at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)
 at java.lang.Thread.run(java.base@11/Thread.java:834)

&quot;Thread-1&quot; #13 prio=5 os_prio=31 cpu=1.43ms elapsed=34.24s tid=0x00007fb08601f800 nid=0x5f03 waiting for monitor entry  [0x000070000bd81000]
   java.lang.Thread.State: BLOCKED (on object monitor)
 at DeadLock.bar(DeadLock.java:33)
 - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)
 - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)
 at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)
 at java.lang.Thread.run(java.base@11/Thread.java:834)

...

JNI global refs: 6, weak refs: 0


Found one Java-level deadlock:
=============================
&quot;Thread-0&quot;:
  waiting to lock monitor 0x00007fb083015900 (object 0x000000061ff904c0, a java.lang.Object),
  which is held by &quot;Thread-1&quot;
&quot;Thread-1&quot;:
  waiting to lock monitor 0x00007fb083015800 (object 0x000000061ff904b0, a java.lang.Object),
  which is held by &quot;Thread-0&quot;

Java stack information for the threads listed above:
===================================================
&quot;Thread-0&quot;:
 at DeadLock.foo(DeadLock.java:18)
 - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)
 - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)
 at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)
 at java.lang.Thread.run(java.base@11/Thread.java:834)
&quot;Thread-1&quot;:
 at DeadLock.bar(DeadLock.java:33)
 - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)
 - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)
 at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)
 at java.lang.Thread.run(java.base@11/Thread.java:834)

Found 1 deadlock.
</code></pre> <p>我们可以看到，<code>jstack</code>不仅会打印线程的栈轨迹、线程状态（BLOCKED）、持有的锁（locked …）以及正在请求的锁（waiting to lock …），而且还会分析出具体的死锁。</p> <h2 id="jcmd"><a href="#jcmd" aria-hidden="true" class="header-anchor">#</a> jcmd</h2> <p>你还可以直接使用<code>jcmd</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html" target="_blank" rel="noopener noreferrer">帮助文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），来替代前面除了<code>jstat</code>之外的所有命令。具体的替换规则你可以参考下表。</p> <p>至于<code>jstat</code>的功能，虽然<code>jcmd</code>复制了<code>jstat</code>的部分代码，并支持通过<code>PerfCounter.print</code>子命令来打印所有的Performance Counter，但是它没有保留<code>jstat</code>的输出格式，也没有重复打印的功能。因此，感兴趣的同学可以自行整理。</p> <p>另外，我们将在下一篇中介绍<code>jcmd</code>中Java Flight Recorder相关的子命令。</p> <h2 id="总结与实践"><a href="#总结与实践" aria-hidden="true" class="header-anchor">#</a> 总结与实践</h2> <p>今天我介绍了JDK中用于监控及诊断的命令行工具。我们再来回顾一下。</p> <ol><li><code>jps</code>将打印所有正在运行的Java进程。</li> <li><code>jstat</code>允许用户查看目标Java进程的类加载、即时编译以及垃圾回收相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。</li> <li><code>jmap</code>允许用户统计目标Java进程的堆中存放的Java对象，并将它们导出成二进制文件。</li> <li><code>jinfo</code>将打印目标Java进程的配置参数，并能够改动其中manageabe的参数。</li> <li><code>jstack</code>将打印目标Java进程中各个线程的栈轨迹、线程状态、锁状况等信息。它还将自动检测死锁。</li> <li><code>jcmd</code>则是一把瑞士军刀，可以用来实现前面除了<code>jstat</code>之外所有命令的功能。</li></ol> <hr> <p>今天的实践环节，你可以探索<code>jcmd</code>中的下述功能，看看有没有适合你项目的监控项：</p> <pre><code>Compiler.CodeHeap_Analytics
Compiler.codecache
Compiler.codelist
Compiler.directives_add
Compiler.directives_clear
Compiler.directives_print
Compiler.directives_remove
Compiler.queue
GC.class_histogram
GC.class_stats
GC.finalizer_info
GC.heap_dump
GC.heap_info
GC.run
GC.run_finalization
VM.class_hierarchy
VM.classloader_stats
VM.classloaders
VM.command_line
VM.dynlibs
VM.flags
VM.info
VM.log
VM.metaspace
VM.native_memory
VM.print_touched_methods
VM.set_flag
VM.stringtable
VM.symboltable
VM.system_properties
VM.systemdictionary
VM.unlock_commercial_features
VM.uptime
VM.version
</code></pre> <p><img src="https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg" alt></p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/jvm/article/40281.html" class="prev">
          29 | 基准测试框架JMH（下）
        </a></span> <span class="next"><a href="/jvm/article/40821.html">
          31 | Java虚拟机的监控及诊断工具（GUI篇）
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/jvm/assets/js/app.d44a01f6.js" defer></script><script src="/jvm/assets/js/35.0b788f34.js" defer></script>
  </body>
</html>
