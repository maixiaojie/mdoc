(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{175:function(t,i,n){"use strict";n.r(i);var e=n(0),r=Object(e.a)({},function(){var t=this,i=t.$createElement,n=t._self._c||i;return n("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),n("p",[t._v("在HotSpot虚拟机中，所有被该注解标注的方法都是HotSpot intrinsic。对这些方法的调用，会被HotSpot虚拟机替换成高效的指令序列。而原本的方法实现则会被忽略掉。")]),t._v(" "),t._m(7),t._v(" "),n("p",[t._v("需要注意的是，其他虚拟机未必维护了这些intrinsic的高效实现，它们可以直接使用原本的较为低效的JDK代码。同样，不同版本的HotSpot虚拟机所实现的intrinsic数量也大不相同。通常越新版本的Java，其intrinsic数量越多。")]),t._v(" "),n("p",[t._v("你或许会产生这么一个疑问：为什么不直接在源代码中使用这些高效实现呢？")]),t._v(" "),n("p",[t._v("这是因为高效实现通常依赖于具体的CPU指令，而这些CPU指令不好在Java源程序中表达。再者，换了一个体系架构，说不定就没有对应的CPU指令，也就无法进行intrinsic优化了。")]),t._v(" "),n("p",[t._v("下面我们便来看几个具体的例子。")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),n("p",[t._v("“恰巧”的是，X86_64体系架构的SSE4.2指令集就包含一条指令PCMPESTRI，让它能够在16字节以下的字符串中，查找另一个16字节以下的字符串，并且返回命中时的索引值。")]),t._v(" "),t._m(10),t._v(" "),n("p",[t._v("另外一个例子则是整数加法的溢出处理。一般我们在做整数加法时，需要考虑结果是否会溢出，并且在溢出的情况下作出相应的处理，以保证程序的正确性。")]),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),n("p",[t._v("在Java层面判断int值之和是否溢出比较费事。我们需要分别比较两个int值与它们的和的符号是否不同。如果都不同，那么我们便认为这两个int值之和溢出。对应的实现便是两个异或操作，一个与操作，以及一个比较操作。")]),t._v(" "),n("p",[t._v("在X86_64体系架构中，大部分计算指令都会更新状态寄存器（FLAGS register），其中就有表示指令结果是否溢出的溢出标识位（overflow flag）。因此，我们只需在加法指令之后比较溢出标志位，便可以知道int值之和是否溢出了。对应的伪代码如下所示：")]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),n("p",[t._v("HotSpot虚拟机中，intrinsic的实现方式分为两种。")]),t._v(" "),t._m(18),t._v(" "),n("p",[t._v("另一种则是特殊的编译器IR节点。显然，这种实现方式仅能够被即时编译器所利用。")]),t._v(" "),n("p",[t._v("在编译过程中，即时编译器会将对原方法的调用的IR节点，替换成特殊的IR节点，并参与接下来的优化过程。最终，即时编译器的后端将根据这些特殊的IR节点，生成指定的CPU指令。大部分的intrinsic都是通过这种方式实现的。")]),t._v(" "),n("p",[t._v("这个替换过程是在方法内联时进行的。当即时编译器碰到方法调用节点时，它将查询目标方法是不是intrinsic。")]),t._v(" "),n("p",[t._v("如果是，则插入相应的特殊IR节点；如果不是，则进行原本的内联工作。（即判断是否需要内联目标方法的方法体，并在需要内联的情况下，将目标方法的IR图纳入当前的编译范围之中。）")]),t._v(" "),n("p",[t._v('也就是说，如果方法调用的目标方法是intrinsic，那么即时编译器会直接忽略原目标方法的字节码，甚至根本不在乎原目标方法是否有字节码。即便是native方法，只要它被标记为intrinsic，即时编译器便能够将之"内联"进来，并插入特殊的IR节点。')]),t._v(" "),n("p",[t._v("事实上，不少被标记为intrinsic的方法都是native方法。原本对这些native方法的调用需要经过JNI（Java Native Interface），其性能开销十分巨大。但是，经过即时编译器的intrinsic优化之后，这部分JNI开销便直接消失不见，并且最终的结果也十分高效。")]),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),n("p",[t._v("最新版本的HotSpot虚拟机定义了三百多个intrinsic。")]),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),n("p",[t._v("如果你想知道HotSpot虚拟机定义的所有intrinsic，那么你可以直接查阅OpenJDK代码[2]。（该链接是Java 12的intrinsic列表。Java 8的intrinsic列表可以查阅这一链接[3]。）")]),t._v(" "),t._m(25),t._v(" "),n("p",[t._v("今天我介绍了HotSpot虚拟机中的intrinsic。")]),t._v(" "),t._m(26),t._v(" "),n("p",[t._v("具体来说，intrinsic的实现有两种。一是不大常见的桩程序，可以在解释执行或者即时编译生成的代码中使用。二是特殊的IR节点。即时编译器将在方法内联过程中，将对intrinsic的调用替换为这些特殊的IR节点，并最终生成指定的CPU指令。")]),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),n("p",[t._v("[1] "),n("a",{attrs:{href:"http://openjdk.java.net/jeps/254",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://openjdk.java.net/jeps/254"),n("OutboundLink")],1),n("br"),t._v("\n[2] "),n("a",{attrs:{href:"http://hg.openjdk.java.net/jdk/hs/file/46dc568d6804/src/hotspot/share/classfile/vmSymbols.hpp#l727",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://hg.openjdk.java.net/jdk/hs/file/46dc568d6804/src/hotspot/share/classfile/vmSymbols.hpp#l727"),n("OutboundLink")],1),n("br"),t._v("\n[3] "),n("a",{attrs:{href:"http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/2af8917ffbee/src/share/vm/classfile/vmSymbols.hpp#l647",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/2af8917ffbee/src/share/vm/classfile/vmSymbols.hpp#l647"),n("OutboundLink")],1)]),t._v(" "),t._m(30)])},[function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("前不久，有同学问我，"),i("code",[this._v("String.indexOf")]),this._v("方法和自己实现的"),i("code",[this._v("indexOf")]),this._v("方法在字节码层面上差不多，为什么执行效率却有天壤之别呢？今天我们就来看一看。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("pre",[i("code",[this._v("public int indexOf(String str) {\n    if (coder() == str.coder()) {\n        return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                          : StringUTF16.indexOf(value, str.value);\n    }\n    if (coder() == LATIN1) {  // str.coder == UTF16\n        return -1;\n    }\n    return StringUTF16.indexOfLatin1(value, str.value);\n}\n")])])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("为了解答这个问题，我们来读一下"),i("code",[this._v("String.indexOf")]),this._v("方法的源代码（上面的代码截取自Java 10.0.2）。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("blockquote",[i("p",[this._v("在Java 9之前，字符串是用char数组来存储的，主要为了支持非英文字符。然而，大多数Java程序中的字符串都是由Latin1字符组成的。也就是说每个字符仅需占据一个字节，而使用char数组的存储方式将极大地浪费内存空间。")]),this._v(" "),i("p",[this._v("Java 9引入了Compact Strings[1]的概念，当字符串仅包含Latin1字符时，使用一个字节代表一个字符的编码格式，使得内存使用效率大大提高。")])])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("假设我们调用"),i("code",[this._v("String.indexOf")]),this._v("方法的调用者以及参数均为只包含Latin1字符的字符串，那么该方法的关键在于对"),i("code",[this._v("StringLatin1.indexOf")]),this._v("方法的调用。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("下面我列举了"),i("code",[this._v("StringLatin1.indexOf")]),this._v("方法的源代码。你会发现，它并没有使用特别高明的算法，唯一值得注意的便是方法声明前的"),i("code",[this._v("@HotSpotIntrinsicCandidate")]),this._v("注解。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("pre",[i("code",[this._v("@HotSpotIntrinsicCandidate\npublic static int indexOf(byte[] value, byte[] str) {\n    if (str.length == 0) {\n        return 0;\n    }\n    if (value.length == 0) {\n        return -1;\n    }\n    return indexOf(value, value.length, str, str.length, 0);\n}\n\n@HotSpotIntrinsicCandidate\npublic static int indexOf(byte[] value, int valueCount, byte[] str, int strCount, int fromIndex) {\n    byte first = str[0];\n    int max = (valueCount - strCount);\n    for (int i = fromIndex; i <= max; i++) {\n        // Look for first character.\n        if (value[i] != first) {\n            while (++i <= max && value[i] != first);\n        }\n        // Found first character, now look at the rest of value\n        if (i <= max) {\n            int j = i + 1;\n            int end = j + strCount - 1;\n            for (int k = 1; j < end && value[j] == str[k]; j++, k++);\n            if (j == end) {\n                // Found whole string.\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n")])])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("换句话说，HotSpot虚拟机将为标注了"),i("code",[this._v("@HotSpotIntrinsicCandidate")]),this._v("注解的方法额外维护一套高效实现。如果Java核心类库的开发者更改了原本的实现，那么虚拟机中的高效实现也需要进行相应的修改，以保证程序语义一致。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("h2",{attrs:{id:"intrinsic与cpu指令"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#intrinsic与cpu指令","aria-hidden":"true"}},[this._v("#")]),this._v(" intrinsic与CPU指令")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("在文章开头的例子中，"),i("code",[this._v("StringLatin1.indexOf")]),this._v("方法将在一个字符串（byte数组）中查找另一个字符串（byte数组），并且返回命中时的索引值，或者-1（未命中）。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("因此，HotSpot虚拟机便围绕着这一指令，开发出X86_64体系架构上的高效实现，并替换原本对"),i("code",[this._v("StringLatin1.indexOf")]),this._v("方法的调用。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("Java核心类库提供了一个"),i("code",[this._v("Math.addExact")]),this._v("方法。它将接收两个int值（或long值）作为参数，并返回这两个int值的和。当这两个int值之和溢出时，该方法将抛出"),i("code",[this._v("ArithmeticException")]),this._v("异常。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("pre",[i("code",[this._v('@HotSpotIntrinsicCandidate\npublic static int addExact(int x, int y) {\n    int r = x + y;\n    // HD 2-12 Overflow iff both arguments have the opposite sign of the result\n    if (((x ^ r) & (y ^ r)) < 0) {\n        throw new ArithmeticException("integer overflow");\n    }\n    return r;\n}\n')])])},function(){var t=this.$createElement,i=this._self._c||t;return i("pre",[i("code",[this._v('public static int addExact(int x, int y) {\n    int r = x + y;\n    jo LABEL_OVERFLOW; // jump if overflow flag set\n    return r;\n    LABEL_OVERFLOW:\n      throw new ArithmeticException("integer overflow");\n      // or deoptimize\n}\n')])])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("最后一个例子则是"),i("code",[this._v("Integer.bitCount")]),this._v("方法，它将统计所输入的int值的二进制形式中有多少个1。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("pre",[i("code",[this._v("@HotSpotIntrinsicCandidate\npublic static int bitCount(int i) {\n    // HD, Figure 5-2\n    i = i - ((i >>> 1) & 0x55555555);\n    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n    i = (i + (i >>> 4)) & 0x0f0f0f0f;\n    i = i + (i >>> 8);\n    i = i + (i >>> 16);\n    return i & 0x3f;\n}\n")])])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("我们可以看到，"),i("code",[this._v("Integer.bitCount")]),this._v("方法的实现还是很巧妙的，但是它需要的计算步骤也比较多。在X86_64体系架构中，我们仅需要一条指令"),i("code",[this._v("popcnt")]),this._v("，便可以直接统计出int值中1的个数。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("h2",{attrs:{id:"intrinsic与方法内联"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#intrinsic与方法内联","aria-hidden":"true"}},[this._v("#")]),this._v(" intrinsic与方法内联")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("一种是独立的桩程序。它既可以被解释执行器利用，直接替换对原方法的调用；也可以被即时编译器所利用，它把代表对原方法的调用的IR节点，替换为对这些桩程序的调用的IR节点。以这种形式实现的intrinsic比较少，主要包括"),i("code",[this._v("Math")]),this._v("类中的一些方法。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("举个例子，我们可以通过"),i("code",[this._v("Thread.currentThread")]),this._v("方法来获取当前线程。这是一个native方法，同时也是一个HotSpot intrinsic。在X86_64体系架构中，R13寄存器存放着当前线程的指针。因此，对该方法的调用将被即时编译器替换为一个特殊IR节点，并最终生成读取R13寄存器指令。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("h2",{attrs:{id:"已有intrinsic简介"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#已有intrinsic简介","aria-hidden":"true"}},[this._v("#")]),this._v(" 已有intrinsic简介")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("在这三百多个intrinsic中，有三成以上是"),i("code",[this._v("Unsafe")]),this._v("类的方法。不过，我们一般不会直接使用"),i("code",[this._v("Unsafe")]),this._v("类的方法，而是通过"),i("code",[this._v("java.util.concurrent")]),this._v("包来间接使用。")])},function(){var t=this,i=t.$createElement,n=t._self._c||i;return n("p",[t._v("举个例子，"),n("code",[t._v("Unsafe")]),t._v("类中经常会被用到的便是"),n("code",[t._v("compareAndSwap")]),t._v("方法（Java 9+更名为"),n("code",[t._v("compareAndSet")]),t._v("或"),n("code",[t._v("compareAndExchange")]),t._v("方法）。在X86_64体系架构中，对这些方法的调用将被替换为"),n("code",[t._v("lock cmpxchg")]),t._v("指令，也就是原子性更新指令。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("除了"),i("code",[this._v("Unsafe")]),this._v("类的方法之外，HotSpot虚拟机中的intrinsic还包括下面的几种。")])},function(){var t=this,i=t.$createElement,n=t._self._c||i;return n("ol",[n("li",[n("code",[t._v("StringBuilder")]),t._v("和"),n("code",[t._v("StringBuffer")]),t._v("类的方法。HotSpot虚拟机将优化利用这些方法构造字符串的方式，以尽量减少需要复制内存的情况。")]),t._v(" "),n("li",[n("code",[t._v("String")]),t._v("类、"),n("code",[t._v("StringLatin1")]),t._v("类、"),n("code",[t._v("StringUTF16")]),t._v("类和"),n("code",[t._v("Arrays")]),t._v("类的方法。HotSpot虚拟机将使用SIMD指令（single instruction multiple data，即用一条指令处理多个数据）对这些方法进行优化。"),n("br"),t._v("\n举个例子，"),n("code",[t._v("Arrays.equals(byte[], byte[])")]),t._v("方法原本是逐个字节比较，在使用了SIMD指令之后，可以放入16字节的XMM寄存器中（甚至是64字节的ZMM寄存器中）批量比较。")]),t._v(" "),n("li",[t._v("基本类型的包装类、"),n("code",[t._v("Object")]),t._v("类、"),n("code",[t._v("Math")]),t._v("类、"),n("code",[t._v("System")]),t._v("类中各个功能性方法，反射API、"),n("code",[t._v("MethodHandle")]),t._v("类中与调用机制相关的方法，压缩、加密相关方法。这部分intrinsic则比较简单，这里就不详细展开了。如果你有感兴趣的，可以自行查阅资料，或者在文末留言。")])])},function(){var t=this.$createElement,i=this._self._c||t;return i("h2",{attrs:{id:"总结与实践"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#总结与实践","aria-hidden":"true"}},[this._v("#")]),this._v(" 总结与实践")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("HotSpot虚拟机将对标注了"),i("code",[this._v("@HotSpotIntrinsicCandidate")]),this._v("注解的方法的调用，替换为直接使用基于特定CPU指令的高效实现。这些方法我们便称之为intrinsic。")])},function(){var t=this,i=t.$createElement,n=t._self._c||i;return n("p",[t._v("HotSpot虚拟机定义了三百多个intrinsic。其中比较特殊的有"),n("code",[t._v("Unsafe")]),t._v("类的方法，基本上使用java.util.concurrent包便会间接使用到"),n("code",[t._v("Unsafe")]),t._v("类的intrinsic。除此之外，"),n("code",[t._v("String")]),t._v("类和"),n("code",[t._v("Arrays")]),t._v("类中的intrinsic也比较特殊。即时编译器将为之生成非常高效的SIMD指令。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[this._v("今天的实践环节，你可以体验一下"),i("code",[this._v("Integer.bitCount")]),this._v(" intrinsic带来的性能提升。")])},function(){var t=this.$createElement,i=this._self._c||t;return i("pre",[i("code",[this._v("// time java Foo\npublic class Foo {\n  public static int bitCount(int i) {\n    // HD, Figure 5-2\n    i = i - ((i >>> 1) & 0x55555555);\n    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n    i = (i + (i >>> 4)) & 0x0f0f0f0f;\n    i = i + (i >>> 8);\n    i = i + (i >>> 16);\n    return i & 0x3f;\n  }\n  public static void main(String[] args) {\n    int sum = 0;\n    for (int i = Integer.MIN_VALUE; i < Integer.MAX_VALUE; i++) {\n      sum += bitCount(i); // In a second run, replace with Integer.bitCount\n    }\n    System.out.println(sum);\n  }\n}\n")])])},function(){var t=this.$createElement,i=this._self._c||t;return i("p",[i("img",{attrs:{src:"https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg",alt:""}})])}],!1,null,null,null);i.default=r.exports}}]);