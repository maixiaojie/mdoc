(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{187:function(e,n,r){"use strict";r.r(n);var a=r(0),t=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"content"},[r("p",[e._v("你好，我是winter。")]),e._v(" "),r("p",[e._v("在我们介绍JavaScript语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。")]),e._v(" "),r("p",[e._v("这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。")]),e._v(" "),r("p",[e._v("实际上，行尾使用分号的风格来自于Java，也来自于C语言和C++，这一设计最初是为了降低编译器的工作负担。")]),e._v(" "),r("p",[e._v("但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好JavaScript语言又提供了相对可用的分号自动补全规则，所以，很多JavaScript的程序员都是倾向于不写分号。")]),e._v(" "),r("p",[e._v("这里要特意说一点，在今天的文章中，我并不希望去售卖自己的观点（其实我是属于“加分号”党），而是希望比较中立地给你讲清楚相关的知识，让你具备足够的判断力。")]),e._v(" "),r("p",[e._v("我们首先来了解一下自动插入分号的规则。")]),e._v(" "),r("h2",{attrs:{id:"自动插入分号规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自动插入分号规则","aria-hidden":"true"}},[e._v("#")]),e._v(" 自动插入分号规则")]),e._v(" "),r("p",[e._v("自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。")]),e._v(" "),r("ul",[r("li",[e._v("要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。")]),e._v(" "),r("li",[e._v("有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。")]),e._v(" "),r("li",[e._v("源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。")])]),e._v(" "),r("p",[e._v("这样描述是比较难以理解的，我们一起看一些实际的例子进行分析：")]),e._v(" "),r("pre",[r("code",[e._v("let a = 1\nvoid function(a){\n    console.log(a);\n}(a);\n")])]),e._v(" "),r("p",[e._v("在这个例子中，第一行的结尾处有换行符，接下来void关键字接在1之后是不合法的，这命中了我们的第一条规则，因此会在void前插入换行符。")]),e._v(" "),r("pre",[r("code",[e._v("var a = 1, b = 1, c = 1;\na\n++\nb\n++\nc\n")])]),e._v(" "),r("p",[e._v("这也是个著名的例子，我们看第二行的a之后，有换行符，后面遇到了++运算符，a后面跟++是合法的语法，但是我们看看JavaScript标准定义中，有[no LineTerminator here]这个字样，这是一个语法定义中的规则，你可以感受一下这个规则的内容（下一小节，我会给你详细介绍no LineTerminator here ）：")]),e._v(" "),r("pre",[r("code",[e._v("UpdateExpression[Yield, Await]:\n    LeftHandSideExpression[?Yield, ?Await]\n    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++\n    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]--\n    ++UnaryExpression[?Yield, ?Await]\n    --UnaryExpression[?Yield, ?Await]\n")])]),e._v(" "),r("p",[e._v("于是，这里a的后面就要插入一个分号了。所以这段代码最终的结果，b和c都变成了2，而a还是1。")]),e._v(" "),r("pre",[r("code",[e._v("(function(a){\n    console.log(a);\n})()\n(function(a){\n    console.log(a);\n})()\n")])]),e._v(" "),r("p",[e._v("这个例子是比较有实际价值的例子，这里两个function调用的写法被称作IIFE（立即执行的函数表达式），是个常见技巧。")]),e._v(" "),r("p",[e._v("这段代码意图上显然是形成两个IIFE。")]),e._v(" "),r("p",[e._v("我们来看第三行结束的位置，JavaScript引擎会认为函数返回的可能是个函数，那么，在后面再跟括号形成函数调用就是合理的，因此这里不会自动插入分号。")]),e._v(" "),r("p",[e._v("这是一些鼓励不写分号的编码风格会要求大家写IIFE时必须在行首加分号的原因。")]),e._v(" "),r("pre",[r("code",[e._v("function f(){\n    return/*\n        This is a return value.\n    */1;\n}\nf();\n")])]),e._v(" "),r("p",[e._v("在这个例子中，return和1被用注释分隔开了。")]),e._v(" "),r("p",[e._v("根据JavaScript自动插入分号规则，"),r("strong",[e._v("带换行符的注释也被认为是有换行符")]),e._v("，而恰好的是，return也有[no LineTerminator here]规则的要求。所以这里会自动插入分号，f执行的返回值是undefined。")]),e._v(" "),r("h2",{attrs:{id:"no-lineterminator-here-规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#no-lineterminator-here-规则","aria-hidden":"true"}},[e._v("#")]),e._v(" no LineTerminator here 规则")]),e._v(" "),r("p",[e._v("好了，到这里我们已经讲清楚了分号自动插入的规则，但是我们要想彻底掌握分号的奥秘，就必须要对JavaScript的语法定义做一些数据挖掘工作。")]),e._v(" "),r("p",[e._v("no LineTerminator here规则表示它所在的结构中的这一位置不能插入换行符。")]),e._v(" "),r("p",[e._v("自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟no LineTerminator here规则强相关，那么我们就找出JavaScript语法定义中的这些规则。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://static001.geekbang.org/resource/image/c3/ad/c3ffbc89e049ad1901d4108c8ad88aad.jpg",alt:""}})]),e._v(" "),r("p",[e._v("为了方便你理解，我把产生式换成了实际的代码。")]),e._v(" "),r("p",[e._v("下面一段代码展示了，带标签的continue语句，不能在continue后插入换行。")]),e._v(" "),r("pre",[r("code",[e._v("outer:for(var j = 0; j < 10; j++)\n    for(var i = 0; i < j; i++)\n        continue /*no LineTerminator here*/ outter\n")])]),e._v(" "),r("p",[e._v("break跟continue是一样的，break后也不能插入换行：")]),e._v(" "),r("pre",[r("code",[e._v("outer:for(var j = 0; j < 10; j++)\n    for(var i = 0; i < j; i++)\n        break /*no LineTerminator here*/ outter\n")])]),e._v(" "),r("p",[e._v("我们前面已经提到过return和后自增、后自减运算符。")]),e._v(" "),r("pre",[r("code",[e._v("function f(){\n    return /*no LineTerminator here*/1;\n}\n\n\ni/*no LineTerminator here*/++\ni/*no LineTerminator here*/--\n")])]),e._v(" "),r("p",[e._v("以及，throw和Exception之间也不能插入换行符：")]),e._v(" "),r("pre",[r("code",[e._v('throw/*no LineTerminator here*/new Exception("error")\n')])]),e._v(" "),r("p",[e._v("凡是async关键字，后面都不能插入换行符：")]),e._v(" "),r("pre",[r("code",[e._v("async/*no LineTerminator here*/function f(){\n\n}\nconst f = async/*no LineTerminator here*/x => x*x\n")])]),e._v(" "),r("p",[e._v("箭头函数的箭头前，也不能插入换行")]),e._v(" "),r("pre",[r("code",[e._v("const f = x/*no LineTerminator here*/=> x*x\n")])]),e._v(" "),r("p",[e._v("yield之后，不能插入换行")]),e._v(" "),r("pre",[r("code",[e._v("function *g(){\n    var i = 0;\n    while(true)\n        yield/*no LineTerminator here*/i++;\n}\n")])]),e._v(" "),r("p",[e._v("到这里，我已经整理了所有标准中的no LineTerminator here规则，实际上，no LineTerminator here规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要我们格外注意。")]),e._v(" "),r("h2",{attrs:{id:"不写分号需要注意的情况"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不写分号需要注意的情况","aria-hidden":"true"}},[e._v("#")]),e._v(" 不写分号需要注意的情况")]),e._v(" "),r("p",[e._v("下面我们来看几种不写分号容易造成错误的情况，你可以稍微注意一下，避免发生同样的问题。")]),e._v(" "),r("h3",{attrs:{id:"以括号开头的语句"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#以括号开头的语句","aria-hidden":"true"}},[e._v("#")]),e._v(" 以括号开头的语句")]),e._v(" "),r("p",[e._v("我们在前面的案例中，已经展示了一种情况，那就是以括号开头的语句：")]),e._v(" "),r("pre",[r("code",[e._v("(function(a){\n    console.log(a);\n})()/*这里没有被自动插入分号*/\n(function(a){\n    console.log(a);\n})()\n")])]),e._v(" "),r("p",[e._v("这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。")]),e._v(" "),r("h3",{attrs:{id:"以数组开头的语句"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#以数组开头的语句","aria-hidden":"true"}},[e._v("#")]),e._v(" 以数组开头的语句")]),e._v(" "),r("p",[e._v("除了括号，以数组开头的语句也十分危险：")]),e._v(" "),r("pre",[r("code",[e._v("var a = [[]]/*这里没有被自动插入分号*/\n[3, 2, 1, 0].forEach(e => console.log(e))\n")])]),e._v(" "),r("p",[e._v("这段代码本意是一个变量a赋值，然后对一个数组执行forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。")]),e._v(" "),r("h3",{attrs:{id:"以正则表达式开头的语句"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#以正则表达式开头的语句","aria-hidden":"true"}},[e._v("#")]),e._v(" 以正则表达式开头的语句")]),e._v(" "),r("p",[e._v("正则表达式开头的语句也值得你去多注意一下。我们来看这个例子。")]),e._v(" "),r("pre",[r("code",[e._v('var x = 1, g = {test:()=>0}, b = 1/*这里没有被自动插入分号*/\n/(a)/g.test("abc")\nconsole.log(RegExp.$1)\n')])]),e._v(" "),r("p",[e._v("这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。")]),e._v(" "),r("p",[e._v("注意，我构造的这个例子跟上面的例子一样，同样不会抛错，凡是这一类情况，都非常致命。")]),e._v(" "),r("h3",{attrs:{id:"以template开头的语句"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#以template开头的语句","aria-hidden":"true"}},[e._v("#")]),e._v(" 以Template开头的语句")]),e._v(" "),r("p",[e._v("以Template开头的语句比较少见，但是跟正则配合时，仍然不是不可能出现：")]),e._v(" "),r("pre",[r("code",[e._v('var f = function(){\n  return "";\n}\nvar g = f/*这里没有被自动插入分号*/\n`Template`.match(/(a)/);\nconsole.log(RegExp.$1)\n')])]),e._v(" "),r("p",[e._v("这段代码本意是声明函数f，然后赋值给g，再测试Template中是否含有字母a。但是因为没有自动插入分号，函数f被认为跟Template一体的，进而被莫名其妙地执行了一次。")]),e._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("p",[e._v("这一节课，我们讨论了要不要加分号的问题。")]),e._v(" "),r("p",[e._v("首先我们介绍了自动插入分号机制，又对JavaScript语法中的no line terminator规则做了个整理，最后，我挑选了几种情况，为你介绍了不写分号需要注意的一些常见的错误。")]),e._v(" "),r("p",[e._v("最后留给你一个问题，请找一些开源项目，看看它们的编码规范是否要求加分号，欢迎留言讨论。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://static001.geekbang.org/resource/image/7c/b1/7ca7c24e92d25bde2e8609ed5386b5b1.jpg",alt:""}})])])}],!1,null,null,null);n.default=t.exports}}]);