(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{173:function(t,e,a){"use strict";a.r(e);var i=a(0),s=Object(i.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("p",[t._v("今天我们继续来聊那些重要的Kafka集群配置，下半部分主要是Topic级别参数、JVM参数以及操作系统参数的设置。")]),t._v(" "),a("p",[t._v("在上一期中，我们讨论了Broker端参数设置的一些法则，但其实Kafka也支持为不同的Topic设置不同的参数值。当前最新的2.2版本总共提供了大约25个Topic级别的参数，当然我们也不必全部了解它们的作用，这里我挑出了一些最关键的参数，你一定要把它们掌握清楚。除了Topic级别的参数，我今天还会给出一些重要的JVM参数和操作系统参数，正确设置这些参数是搭建高性能Kafka集群的关键因素。")]),t._v(" "),t._m(0),t._v(" "),a("p",[t._v("说起Topic级别的参数，你可能会有这样的疑问：如果同时设置了Topic级别参数和全局Broker参数，到底听谁的呢？哪个说了算呢？答案就是Topic级别参数会覆盖全局Broker参数的值，而每个Topic都能设置自己的参数值，这就是所谓的Topic级别参数。")]),t._v(" "),a("p",[t._v("举个例子说明一下，上一期我提到了消息数据的留存时间参数，在实际生产环境中，如果为所有Topic的数据都保存相当长的时间，这样做既不高效也无必要。更适当的做法是允许不同部门的Topic根据自身业务需要，设置自己的留存时间。如果只能设置全局Broker参数，那么势必要提取所有业务留存时间的最大值作为全局参数值，此时设置Topic级别参数把它覆盖，就是一个不错的选择。")]),t._v(" "),a("p",[t._v("下面我们依然按照用途分组的方式引出重要的Topic级别参数。从保存消息方面来考量的话，下面这组参数是非常重要的：")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),a("p",[t._v("好了，你要掌握的Topic级别的参数就这么几个。下面我来说说怎么设置Topic级别参数吧。其实说到这个事情，我是有点个人看法的：我本人不太赞同那种做一件事情开放给你很多种选择的设计方式，看上去好似给用户多种选择，但实际上只会增加用户的学习成本。特别是系统配置，如果你告诉我只能用一种办法来做，我会很努力地把它学会；反之，如果你告诉我说有两种方法甚至是多种方法都可以实现，那么我可能连学习任何一种方法的兴趣都没有了。Topic级别参数的设置就是这种情况，我们有两种方式可以设置：")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),a("p",[t._v("我在专栏前面提到过，Kafka服务器端代码是用Scala语言编写的，但终归还是编译成Class文件在JVM上运行，因此JVM参数设置对于Kafka集群的重要性不言而喻。")]),t._v(" "),a("p",[t._v("首先我先说说Java版本，我个人极其不推荐将Kafka运行在Java 6或7的环境上。Java 6实在是太过陈旧了，没有理由不升级到更新版本。另外Kafka自2.0.0版本开始，已经正式摒弃对Java 7的支持了，所以有条件的话至少使用Java 8吧。")]),t._v(" "),a("p",[t._v("说到JVM端设置，堆大小这个参数至关重要。虽然在后面我们还会讨论如何调优Kafka性能的问题，但现在我想无脑给出一个通用的建议：将你的JVM堆大小设置成6GB吧，这是目前业界比较公认的一个合理值。我见过很多人就是使用默认的Heap Size来跑Kafka，说实话默认的1GB有点小，毕竟Kafka Broker在与客户端进行交互时会在JVM堆上创建大量的ByteBuffer实例，Heap Size不能太小。")]),t._v(" "),a("p",[t._v("JVM端配置的另一个重要参数就是垃圾回收器的设置，也就是平时常说的GC设置。如果你依然在使用Java 7，那么可以根据以下法则选择合适的垃圾回收器：")]),t._v(" "),t._m(11),t._v(" "),a("p",[t._v("当然了，如果你已经在使用Java 8了，那么就用默认的G1收集器就好了。在没有任何调优的情况下，G1表现得要比CMS出色，主要体现在更少的Full GC，需要调整的参数更少等，所以使用G1就好了。")]),t._v(" "),a("p",[t._v("现在我们确定好了要设置的JVM参数，我们该如何为Kafka进行设置呢？有些奇怪的是，这个问题居然在Kafka官网没有被提及。其实设置的方法也很简单，你只需要设置下面这两个环境变量即可：")]),t._v(" "),t._m(12),t._v(" "),a("p",[t._v("比如你可以这样启动Kafka Broker，即在启动Kafka Broker之前，先设置上这两个环境变量：")]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),a("p",[t._v("最后我们来聊聊Kafka集群通常都需要设置哪些操作系统参数。通常情况下，Kafka并不需要设置太多的OS参数，但有些因素最好还是关注一下，比如下面这几个：")]),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),a("p",[t._v("其次是文件系统类型的选择。这里所说的文件系统指的是如ext3、ext4或XFS这样的日志型文件系统。根据官网的测试报告，XFS的性能要强于ext4，所以生产环境最好还是使用XFS。对了，最近有个Kafka使用ZFS的"),a("a",{attrs:{href:"https://www.confluent.io/kafka-summit-sf18/kafka-on-zfs",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据报告"),a("OutboundLink")],1),t._v("，貌似性能更加强劲，有条件的话不妨一试。")]),t._v(" "),a("p",[t._v("第三是swap的调优。网上很多文章都提到设置其为0，将swap完全禁掉以防止Kafka进程使用swap空间。我个人反倒觉得还是不要设置成0比较好，我们可以设置成一个较小的值。为什么呢？因为一旦设置成0，当物理内存耗尽时，操作系统会触发OOM killer这个组件，它会随机挑选一个进程然后kill掉，即根本不给用户任何的预警。但如果设置成一个比较小的值，当开始使用swap空间时，你至少能够观测到Broker性能开始出现急剧下降，从而给你进一步调优和诊断问题的时间。基于这个考虑，我个人建议将swappniess配置成一个接近0但不为0的值，比如1。")]),t._v(" "),a("p",[t._v("最后是提交时间或者说是Flush落盘时间。向Kafka发送数据并不是真要等数据被写入磁盘才会认为成功，而是只要数据被写入到操作系统的页缓存（Page Cache）上就可以了，随后操作系统根据LRU算法会定期将页缓存上的“脏”数据落盘到物理磁盘上。这个定期就是由提交时间来确定的，默认是5秒。一般情况下我们会认为这个时间太频繁了，可以适当地增加提交间隔来降低物理磁盘的写操作。当然你可能会有这样的疑问：如果在页缓存中的数据在写入到磁盘前机器宕机了，那岂不是数据就丢失了。的确，这种情况数据确实就丢失了，但鉴于Kafka在软件层面已经提供了多副本的冗余机制，因此这里稍微拉大提交间隔去换取性能还是一个合理的做法。")]),t._v(" "),t._m(17),t._v(" "),a("p",[t._v("今天我和你分享了关于Kafka集群设置的各类配置，包括Topic级别参数、JVM参数以及操作系统参数，连同上一篇一起构成了完整的Kafka参数配置列表。我希望这些最佳实践能够在你搭建Kafka集群时助你一臂之力，但切记配置因环境而异，一定要结合自身业务需要以及具体的测试来验证它们的有效性。")]),t._v(" "),t._m(18),t._v(" "),a("p",[t._v("很多人争论Kafka不需要为Broker设置太大的堆内存，而应该尽可能地把内存留给页缓存使用。对此你是怎么看的？在你的实际使用中有哪些好的法则来评估Kafka对内存的使用呢？")]),t._v(" "),a("p",[t._v("欢迎写下你的思考和答案，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。")]),t._v(" "),t._m(19)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"topic级别参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#topic级别参数","aria-hidden":"true"}},[this._v("#")]),this._v(" Topic级别参数")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("retention.ms")]),this._v("：规定了该Topic消息被保存的时长。默认是7天，即该Topic只保存最近7天的消息。一旦设置了这个值，它会覆盖掉Broker端的全局参数值。")]),this._v(" "),e("li",[e("code",[this._v("retention.bytes")]),this._v("：规定了要为该Topic预留多大的磁盘空间。和全局参数作用相似，这个值通常在多租户的Kafka集群中会有用武之地。当前默认值是-1，表示可以无限使用磁盘空间。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("上面这些是从保存消息的维度来说的。如果从能处理的消息大小这个角度来看的话，有一个参数是必须要设置的，即"),e("code",[this._v("max.message.bytes")]),this._v("。它决定了Kafka Broker能够正常接收该Topic的最大消息大小。我知道目前在很多公司都把Kafka作为一个基础架构组件来运行，上面跑了很多的业务数据。如果在全局层面上，我们不好给出一个合适的最大消息值，那么不同业务部门能够自行设定这个Topic级别参数就显得非常必要了。在实际场景中，这种用法也确实是非常常见的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("创建Topic时进行设置")]),this._v(" "),e("li",[this._v("修改Topic时设置")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("我们先来看看如何在创建Topic时设置这些参数。我用上面提到的"),e("code",[this._v("retention.ms")]),this._v("和"),e("code",[this._v("max.message.bytes")]),this._v("举例。设想你的部门需要将交易数据发送到Kafka进行处理，需要保存最近半年的交易数据，同时这些数据很大，通常都有几MB，但一般不会超过5MB。现在让我们用以下命令来创建Topic：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("bin/kafka-topics.sh--bootstrap-serverlocalhost:9092--create--topictransaction--partitions1--replication-factor1--configretention.ms=15552000000--configmax.message.bytes=5242880\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("我们只需要知道Kafka开放了"),e("code",[this._v("kafka-topics")]),this._v("命令供我们来创建Topic即可。对于上面这样一条命令，请注意结尾处的"),e("code",[this._v("--config")]),this._v("设置，我们就是在config后面指定了想要设置的Topic级别参数。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("下面看看使用另一个自带的命令"),e("code",[this._v("kafka-configs")]),this._v("来修改Topic级别参数。假设我们现在要发送最大值是10MB的消息，该如何修改呢？命令如下：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v(" bin/kafka-configs.sh--zookeeperlocalhost:2181--entity-typetopics--entity-nametransaction--alter--add-configmax.message.bytes=10485760\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("总体来说，你只能使用这么两种方式来设置Topic级别参数。我个人的建议是，你最好始终坚持使用第二种方式来设置，并且在未来，Kafka社区很有可能统一使用"),e("code",[this._v("kafka-configs")]),this._v("脚本来调整Topic级别参数。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"jvm参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm参数","aria-hidden":"true"}},[this._v("#")]),this._v(" JVM参数")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("如果Broker所在机器的CPU资源非常充裕，建议使用CMS收集器。启用方法是指定"),e("code",[this._v("-XX:+UseCurrentMarkSweepGC")]),this._v("。")]),this._v(" "),e("li",[this._v("否则，使用吞吐量收集器。开启方法是指定"),e("code",[this._v("-XX:+UseParallelGC")]),this._v("。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("KAFKA_HEAP_OPTS")]),this._v("：指定堆大小。")]),this._v(" "),e("li",[e("code",[this._v("KAFKA_JVM_PERFORMANCE_OPTS")]),this._v("：指定GC参数。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("$> export KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g\n$> export  KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true\n$> bin/kafka-server-start.sh config/server.properties\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"操作系统参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作系统参数","aria-hidden":"true"}},[this._v("#")]),this._v(" 操作系统参数")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("文件描述符限制")]),this._v(" "),e("li",[this._v("文件系统类型")]),this._v(" "),e("li",[this._v("Swappiness")]),this._v(" "),e("li",[this._v("提交时间")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("首先是"),e("code",[this._v("ulimit -n")]),this._v("。我觉得任何一个Java项目最好都调整下这个值。实际上，文件描述符系统资源并不像我们想象的那样昂贵，你不用太担心调大此值会有什么不利的影响。通常情况下将它设置成一个超大的值是合理的做法，比如"),e("code",[this._v("ulimit -n 1000000")]),this._v("。还记得电影《让子弹飞》里的对话吗：“你和钱，谁对我更重要？都不重要，没有你对我很重要！”。这个参数也有点这么个意思。其实设置这个参数一点都不重要，但不设置的话后果很严重，比如你会经常看到“Too many open files”的错误。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[this._v("#")]),this._v(" 小结")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"开放讨论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开放讨论","aria-hidden":"true"}},[this._v("#")]),this._v(" 开放讨论")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://static001.geekbang.org/resource/image/c8/bf/c89da43deab85fe7cb06acec867aa5bf.jpg",alt:""}})])}],!1,null,null,null);e.default=s.exports}}]);