(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{171:function(e,t,s){"use strict";s.r(t);var n=s(0),_=Object(n.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),s("p",[e._v("把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。")]),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),s("p",[e._v("执行栈可视化")]),e._v(" "),e._m(12),e._v(" "),s("p",[e._v("平时在开发中，大家也可以在报错中找到执行栈的痕迹")]),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),s("p",[e._v("函数执行顺序")]),e._v(" "),e._m(15),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),s("p",[e._v("爆栈")]),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),e._m(22),e._v(" "),s("p",[e._v("事件循环")]),e._v(" "),e._m(23),e._v(" "),e._m(24),e._v(" "),e._m(25),e._v(" "),e._m(26),e._v(" "),e._m(27),e._v(" "),e._m(28),e._v(" "),e._m(29),e._v(" "),s("p",[e._v("也就是说，如果 "),s("code",[e._v("await")]),e._v(" 后面跟着 "),s("code",[e._v("Promise")]),e._v(" 的话，"),s("code",[e._v("async1 end")]),e._v(" 需要等待三个 tick 才能执行到。那么其实这个性能相对来说还是略慢的，所以 V8 团队借鉴了 Node 8 中的一个 Bug，在引擎底层将三次 tick 减少到了二次 tick。但是这种做法其实是违法了规范的，当然规范也是可以更改的，这是 V8 团队的一个 "),s("a",{attrs:{href:"https://github.com/tc39/ecma262/pull/1250",target:"_blank",rel:"noopener noreferrer"}},[e._v("PR"),s("OutboundLink")],1),e._v("，目前已被同意这种做法。")]),e._v(" "),s("p",[e._v("所以 Event Loop 执行顺序如下所示：")]),e._v(" "),e._m(30),e._v(" "),e._m(31),e._v(" "),e._m(32),e._v(" "),e._m(33),e._v(" "),e._m(34),e._v(" "),e._m(35),e._v(" "),e._m(36),e._v(" "),s("p",[e._v("Node 中的 Event Loop 和浏览器中的是完全不相同的东西。")]),e._v(" "),e._m(37),e._v(" "),e._m(38),e._v(" "),e._m(39),e._v(" "),e._m(40),e._v(" "),e._m(41),e._v(" "),e._m(42),e._v(" "),e._m(43),e._v(" "),e._m(44),e._v(" "),s("p",[e._v("idle, prepare 阶段内部实现，这里就忽略不讲了。")]),e._v(" "),e._m(45),e._v(" "),s("p",[e._v("poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情")]),e._v(" "),e._m(46),e._v(" "),s("p",[e._v("并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情")]),e._v(" "),e._m(47),e._v(" "),s("p",[e._v("当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。")]),e._v(" "),e._m(48),e._v(" "),e._m(49),e._v(" "),e._m(50),e._v(" "),s("p",[e._v("close callbacks 阶段执行 close 事件")]),e._v(" "),s("p",[e._v("在以上的内容中，我们了解了 Node 中的 Event Loop 的执行顺序，接下来我们将会通过代码的方式来深入理解这块内容。")]),e._v(" "),e._m(51),e._v(" "),e._m(52),e._v(" "),e._m(53),e._v(" "),e._m(54),e._v(" "),s("p",[e._v("当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：")]),e._v(" "),e._m(55),e._v(" "),e._m(56),e._v(" "),e._m(57),e._v(" "),e._m(58),e._v(" "),e._m(59),e._v(" "),s("p",[e._v("对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。")]),e._v(" "),e._m(60),e._v(" "),e._m(61),e._v(" "),s("p",[e._v("对于以上代码，大家可以发现无论如何，永远都是先把 nextTick 全部打印出来。")]),e._v(" "),e._m(62),e._v(" "),s("p",[e._v("这一章节我们学习了 JS 实现异步的原理，并且了解了在浏览器和 Node 中 Event Loop 其实是不相同的。Event Loop 这个知识点对于我们理解 JS 是如何执行的至关重要，同时也是常考题。如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。")])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"event-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#event-loop","aria-hidden":"true"}},[this._v("#")]),this._v(" Event Loop")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在前两章节中我们了解了 JS 异步相关的知识。在实践的过程中，你是否遇到过以下场景，为什么 "),t("code",[this._v("setTimeout")]),this._v(" 会比 "),t("code",[this._v("Promise")]),this._v(" 后执行，明明代码写在 "),t("code",[this._v("Promise")]),this._v(" 之前。这其实涉及到了 Event Loop 相关的知识，这一章节我们会来详细地了解 Event Loop 相关知识，知道 JS 异步运行代码的原理，并且这一章节也是面试常考知识点。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"进程与线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程","aria-hidden":"true"}},[this._v("#")]),this._v(" 进程与线程")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("涉及面试题：进程与线程区别？JS 单线程带来的好处？")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("相信大家经常会听到 JS 是"),t("strong",[this._v("单线程")]),this._v("执行的，但是你是否疑惑过什么是线程？")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 CPU "),t("strong",[this._v("工作时间片")]),this._v("的一个描述。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("进程描述了 CPU 在"),t("strong",[this._v("运行指令及加载和保存上下文所需的时间")]),this._v("，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("上文说到了 JS 引擎线程和渲染线程，大家应该都知道，在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是"),t("strong",[this._v("互斥")]),this._v("的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"执行栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行栈","aria-hidden":"true"}},[this._v("#")]),this._v(" 执行栈")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("涉及面试题：什么是执行栈？")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("可以把执行栈认为是一个存储函数调用的"),t("strong",[this._v("栈结构")]),this._v("，遵循先进后出的原则。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/13/1670d2d20ead32ec?w=1211&h=623&f=gif&s=140580",alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("当开始执行 JS 代码时，首先会执行一个 "),t("code",[this._v("main")]),this._v(" 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，"),t("code",[this._v("foo")]),this._v(" 函数后执行，当执行完毕后就从栈中弹出了。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("function foo() {\n  throw new Error('error')\n}\nfunction bar() {\n  foo()\n}\nbar()\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/13/1670c0e21540090c?w=614&h=121&f=png&s=18244",alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("大家可以在上图清晰的看到报错在 "),t("code",[this._v("foo")]),this._v(" 函数，"),t("code",[this._v("foo")]),this._v(" 函数又是在 "),t("code",[this._v("bar")]),this._v(" 函数中调用的。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("当我们使用递归的时候，因为栈可存放的函数是有"),t("strong",[this._v("限制")]),this._v("的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("function bar() {\n  bar()\n}\nbar()\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/13/1670c128acce975f?w=511&h=158&f=png&s=12192",alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"浏览器中的-event-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的-event-loop","aria-hidden":"true"}},[this._v("#")]),this._v(" 浏览器中的 Event Loop")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("涉及面试题：异步代码执行顺序？解释一下什么是 Event Loop ？")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("上一小节我们讲到了什么是执行栈，大家也知道了当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被"),t("strong",[this._v("挂起")]),this._v("并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/23/16740fa4cd9c6937?w=3161&h=1274&f=png&s=202906",alt:""}})])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v("不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 "),s("strong",[e._v("微任务")]),e._v("（microtask） 和 "),s("strong",[e._v("宏任务")]),e._v("（macrotask）。在 ES6 规范中，microtask 称为 "),s("code",[e._v("jobs")]),e._v("，macrotask 称为 "),s("code",[e._v("task")]),e._v("。下面来看以下代码的执行顺序：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("console.log('script start')\n\nasync function async1() {\n  await async2()\n  console.log('async1 end')\n}\nasync function async2() {\n  console.log('async2 end')\n}\nasync1()\n\nsetTimeout(function() {\n  console.log('setTimeout')\n}, 0)\n\nnew Promise(resolve => {\n  console.log('Promise')\n  resolve()\n})\n  .then(function() {\n    console.log('promise1')\n  })\n  .then(function() {\n    console.log('promise2')\n  })\n\nconsole.log('script end')\n// script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("注意：新的浏览器中不是如上打印的，因为 await 变快了，具体内容可以往下看")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v("首先先来解释下上述代码的 "),s("code",[e._v("async")]),e._v(" 和 "),s("code",[e._v("await")]),e._v(" 的执行顺序。当我们调用 "),s("code",[e._v("async1")]),e._v(" 函数时，会马上输出 "),s("code",[e._v("async2 end")]),e._v("，并且函数返回一个 "),s("code",[e._v("Promise")]),e._v("，接下来在遇到 "),s("code",[e._v("await")]),e._v("的时候会就让出线程开始执行 "),s("code",[e._v("async1")]),e._v(" 外的代码，所以我们完全可以把 "),s("code",[e._v("await")]),e._v(" 看成是"),s("strong",[e._v("让出线程")]),e._v("的标志。")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v("然后当同步代码全部执行完毕以后，就会去执行所有的异步代码，那么又会回到 "),s("code",[e._v("await")]),e._v(" 的位置执行返回的 "),s("code",[e._v("Promise")]),e._v(" 的 "),s("code",[e._v("resolve")]),e._v(" 函数，这又会把 "),s("code",[e._v("resolve")]),e._v(" 丢到微任务队列中，接下来去执行 "),s("code",[e._v("then")]),e._v(" 中的回调，当两个 "),s("code",[e._v("then")]),e._v(" 中的回调全部执行完毕以后，又会回到 "),s("code",[e._v("await")]),e._v(" 的位置处理返回值，这时候你可以看成是 "),s("code",[e._v("Promise.resolve(返回值).then()")]),e._v("，然后 "),s("code",[e._v("await")]),e._v(" 后的代码全部被包裹进了 "),s("code",[e._v("then")]),e._v(" 的回调中，所以 "),s("code",[e._v("console.log('async1 end')")]),e._v(" 会优先执行于 "),s("code",[e._v("setTimeout")]),e._v("。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("如果你觉得上面这段解释还是有点绕，那么我把 "),t("code",[this._v("async")]),this._v(" 的这两个函数改造成你一定能理解的代码")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("new Promise((resolve, reject) => {\n  console.log('async2 end')\n  // Promise.resolve() 将代码插入微任务队列尾部\n  // resolve 再次插入微任务队列尾部\n  resolve(Promise.resolve())\n}).then(() => {\n  console.log('async1 end')\n})\n")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ul",[s("li",[e._v("首先执行同步代码，这属于宏任务")]),e._v(" "),s("li",[e._v("当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行")]),e._v(" "),s("li",[e._v("执行所有微任务")]),e._v(" "),s("li",[e._v("当执行完所有微任务后，如有必要会渲染页面")]),e._v(" "),s("li",[e._v("然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 "),s("code",[e._v("setTimeout")]),e._v(" 中的回调函数")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v("所以以上代码虽然 "),s("code",[e._v("setTimeout")]),e._v(" 写在 "),s("code",[e._v("Promise")]),e._v(" 之前，但是因为 "),s("code",[e._v("Promise")]),e._v(" 属于微任务而 "),s("code",[e._v("setTimeout")]),e._v(" 属于宏任务，所以会有以上的打印。")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v("微任务包括 "),s("code",[e._v("process.nextTick")]),e._v(" ，"),s("code",[e._v("promise")]),e._v(" ，"),s("code",[e._v("MutationObserver")]),e._v("，其中 "),s("code",[e._v("process.nextTick")]),e._v(" 为 Node 独有。")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v("宏任务包括 "),s("code",[e._v("script")]),e._v(" ， "),s("code",[e._v("setTimeout")]),e._v(" ，"),s("code",[e._v("setInterval")]),e._v(" ，"),s("code",[e._v("setImmediate")]),e._v(" ，"),s("code",[e._v("I/O")]),e._v(" ，"),s("code",[e._v("UI rendering")]),e._v("。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 "),t("code",[this._v("script")]),this._v(" ，浏览器会"),t("strong",[this._v("先执行一个宏任务")]),this._v("，接下来有异步代码的话才会先执行微任务。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"node-中的-event-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-中的-event-loop","aria-hidden":"true"}},[this._v("#")]),this._v(" Node 中的 Event Loop")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("涉及面试题：Node 中的 Event Loop 和浏览器中的有什么区别？process.nexttick 执行顺序？")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Node 的 Event Loop 分为 6 个阶段，它们会按照"),t("strong",[this._v("顺序")]),this._v("反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/13/1670c3fe3f9a5e2b?w=745&h=442&f=png&s=26036",alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"timer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#timer","aria-hidden":"true"}},[this._v("#")]),this._v(" timer")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("timers 阶段会执行 "),t("code",[this._v("setTimeout")]),this._v(" 和 "),t("code",[this._v("setInterval")]),this._v(" 回调，并且是由 poll 阶段控制的。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("同样，在 Node 中定时器指定的时间也不是准确时间，只能是"),t("strong",[this._v("尽快")]),this._v("执行。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"i-o"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i-o","aria-hidden":"true"}},[this._v("#")]),this._v(" I/O")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("I/O 阶段会处理一些上一轮循环中的"),t("strong",[this._v("少数未执行")]),this._v("的 I/O 回调")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"idle-prepare"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#idle-prepare","aria-hidden":"true"}},[this._v("#")]),this._v(" idle, prepare")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"poll"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#poll","aria-hidden":"true"}},[this._v("#")]),this._v(" poll")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[this._v("回到 timer 阶段执行回调")]),this._v(" "),t("li",[this._v("执行 I/O 回调")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ul",[s("li",[e._v("如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制")]),e._v(" "),s("li",[e._v("如果 poll 队列为空时，会有两件事发生\n"),s("ul",[s("li",[e._v("如果有 "),s("code",[e._v("setImmediate")]),e._v(" 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调")]),e._v(" "),s("li",[e._v("如果没有 "),s("code",[e._v("setImmediate")]),e._v(" 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"check"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#check","aria-hidden":"true"}},[this._v("#")]),this._v(" check")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("check 阶段执行 "),t("code",[this._v("setImmediate")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"close-callbacks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#close-callbacks","aria-hidden":"true"}},[this._v("#")]),this._v(" close callbacks")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("首先在有些情况下，定时器的执行顺序其实是"),t("strong",[this._v("随机")]),this._v("的")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("setTimeout(() => {\n    console.log('setTimeout')\n}, 0)\nsetImmediate(() => {\n    console.log('setImmediate')\n})\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("对于以上代码来说，"),t("code",[this._v("setTimeout")]),this._v(" 可能执行在前，也可能执行在后")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ul",[s("li",[e._v("首先 "),s("code",[e._v("setTimeout(fn, 0) === setTimeout(fn, 1)")]),e._v("，这是由源码决定的")]),e._v(" "),s("li",[e._v("进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 "),s("code",[e._v("setTimeout")]),e._v(" 回调")]),e._v(" "),s("li",[e._v("那么如果准备时间花费小于 1ms，那么就是 "),s("code",[e._v("setImmediate")]),e._v(" 回调先执行了")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("const fs = require('fs')\n\nfs.readFile(__filename, () => {\n    setTimeout(() => {\n        console.log('timeout');\n    }, 0)\n    setImmediate(() => {\n        console.log('immediate')\n    })\n})\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在上述代码中，"),t("code",[this._v("setImmediate")]),this._v(" 永远"),t("strong",[this._v("先执行")]),this._v("。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 "),t("code",[this._v("setImmediate")]),this._v(" 回调，所以就直接跳转到 check 阶段去执行回调了。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("上面介绍的都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前"),t("strong",[this._v("清空")]),this._v(" microtask 队列，下图中的 Tick 就代表了 microtask")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/14/16710fb80dd42d27?w=644&h=1227&f=png&s=18741",alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("setTimeout(() => {\n  console.log('timer21')\n}, 0)\n\nPromise.resolve().then(function() {\n  console.log('promise1')\n})\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("最后我们来讲讲 Node 中的 "),t("code",[this._v("process.nextTick")]),this._v("，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会"),t("strong",[this._v("清空队列中的所有回调函数")]),this._v("，并且优先于其他 microtask 执行。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("setTimeout(() => {\n console.log('timer1')\n\n Promise.resolve().then(function() {\n   console.log('promise1')\n })\n}, 0)\n\nprocess.nextTick(() => {\n console.log('nextTick')\n process.nextTick(() => {\n   console.log('nextTick')\n   process.nextTick(() => {\n     console.log('nextTick')\n     process.nextTick(() => {\n       console.log('nextTick')\n     })\n   })\n })\n})\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[this._v("#")]),this._v(" 小结")])}],!1,null,null,null);t.default=_.exports}}]);