(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{189:function(t,e,n){"use strict";n.r(e);var i=n(0),r=Object(i.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[t._m(0),t._v(" "),n("p",[t._v("这一章节我们将来学习数据结构的内容。经常会有人提问说：学习数据结构或者算法对于前端工程师有用么？")]),t._v(" "),n("p",[t._v("总的来说，这些基础学科在短期内收效确实甚微，但是我们首先不要将自己局限在前端工程师这点上。笔者之前是做 iOS 开发的，转做前端以后，只有两个技能还对我有用：")]),t._v(" "),t._m(1),t._v(" "),n("p",[t._v("其他 iOS 上积累的经验，转行以后基本就没多大用处了。所以说，当我们把视野放到编程这个角度去说，数据结构算法一定是有用的，并且也是你未来的一个天花板。可以不花费集中的时间去学习这些内容，但是一定需要时常去学习一点，因为这些技能可以实实在在提升你写代码的能力。")]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),n("p",[t._v("在进入正题之前，我们先来了解下什么是时间复杂度。")]),t._v(" "),n("p",[t._v("通常使用最差的时间复杂度来衡量一个算法的好坏。")]),t._v(" "),n("p",[t._v("常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。")]),t._v(" "),n("p",[t._v("对于一个算法来说，可能会计算出操作次数为 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。")]),t._v(" "),n("p",[t._v("当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。")]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),n("p",[t._v("栈是一个线性结构，在计算机中是一个相当常见的数据结构。")]),t._v(" "),n("p",[t._v("栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),n("p",[t._v("每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),n("p",[t._v("选取了 "),n("a",{attrs:{href:"https://leetcode.com/problems/valid-parentheses/submissions/1",target:"_blank",rel:"noopener noreferrer"}},[t._v("LeetCode 上序号为 20 的题目"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("题意是匹配括号，可以通过栈的特性来完成这道题目")]),t._v(" "),t._m(10),t._v(" "),n("p",[t._v("其实在 Vue 中关于模板解析的代码，就有应用到匹配尖括号的内容。")]),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),n("p",[t._v("队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。")]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),n("p",[t._v("这里会讲解两种实现队列的方式，分别是单链队列和循环队列。")]),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),n("p",[t._v("因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。")]),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),n("p",[t._v("链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。")]),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),n("p",[t._v("树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。")]),t._v(" "),n("p",[t._v("二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。")]),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),n("p",[t._v("二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。")]),t._v(" "),n("p",[t._v("这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。")]),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),n("p",[t._v("以上是最基本的二分搜索树实现，接下来实现树的遍历。")]),t._v(" "),n("p",[t._v("对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。")]),t._v(" "),t._m(32),t._v(" "),n("p",[t._v("以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。")]),t._v(" "),t._m(33),t._v(" "),n("p",[t._v("接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反")]),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),n("p",[t._v("接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况")]),t._v(" "),t._m(39),t._v(" "),n("p",[t._v("对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。")]),t._v(" "),t._m(40),t._v(" "),n("p",[t._v("最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。")]),t._v(" "),n("p",[t._v("当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。")]),t._v(" "),n("p",[t._v("你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。")]),t._v(" "),t._m(41),t._v(" "),t._m(42),t._v(" "),t._m(43),t._v(" "),n("p",[t._v("二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。")]),t._v(" "),n("p",[t._v("AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。")]),t._v(" "),t._m(44),t._v(" "),n("p",[t._v("因为 AVL 树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不作再次解析。")]),t._v(" "),n("p",[t._v("对于 AVL 树来说，添加节点会有四种情况")]),t._v(" "),t._m(45),t._v(" "),n("p",[t._v("对于左左情况来说，新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。")]),t._v(" "),n("p",[t._v("旋转之前：new < 2 < C < 3 < B < 5 < A，右旋之后节点 3 为根节点，这时候需要将节点 3 的右节点加到节点 5 的左边，最后还需要更新节点的高度。")]),t._v(" "),n("p",[t._v("对于右右情况来说，相反于左左情况，所以不再赘述。")]),t._v(" "),n("p",[t._v("对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来达到目的。")]),t._v(" "),n("p",[t._v("首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。")]),t._v(" "),t._m(46),t._v(" "),t._m(47),t._v(" "),t._m(48),t._v(" "),t._m(49),t._v(" "),n("p",[t._v("简单点来说，这个结构的作用大多是为了方便搜索字符串，该树有以下几个特点")]),t._v(" "),t._m(50),t._v(" "),t._m(51),t._v(" "),n("p",[t._v("、")]),t._v(" "),t._m(52),t._v(" "),n("p",[t._v("总得来说 Trie 的实现相比别的树结构来说简单的很多，实现就以搜索英文字符为例。")]),t._v(" "),t._m(53),t._v(" "),t._m(54),t._v(" "),t._m(55),t._v(" "),n("p",[t._v("并查集是一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。")]),t._v(" "),n("p",[t._v("这个结构中有两个重要的操作，分别是：")]),t._v(" "),t._m(56),t._v(" "),t._m(57),t._v(" "),t._m(58),t._v(" "),t._m(59),t._v(" "),t._m(60),t._v(" "),t._m(61),t._v(" "),n("p",[t._v("堆通常是一个可以被看做一棵树的数组对象。")]),t._v(" "),t._m(62),t._v(" "),t._m(63),t._v(" "),t._m(64),t._v(" "),n("p",[t._v("优先队列也完全可以用堆来实现，操作是一模一样的。")]),t._v(" "),t._m(65),t._v(" "),t._m(66),t._v(" "),t._m(67),t._v(" "),t._m(68),t._v(" "),t._m(69),t._v(" "),t._m(70),t._v(" "),t._m(71),t._v(" "),t._m(72),t._v(" "),n("p",[t._v("这一章节我们学习了一些常见的数据结构，当然我没有将其他更难的数据结构也放进来，能够掌握这些常见的内容已经足够解决大部分的问题了。当然你如果还想继续深入学习数据结构，可以阅读 "),n("a",{attrs:{href:"https://book.douban.com/subject/19952400/",target:"_blank",rel:"noopener noreferrer"}},[t._v("算法第四版"),n("OutboundLink")],1),t._v(" 以及在 "),n("a",{attrs:{href:"https://leetcode-cn.com/problemset/all/",target:"_blank",rel:"noopener noreferrer"}},[t._v("leetcode"),n("OutboundLink")],1),t._v(" 中实践。")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"常见数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见数据结构","aria-hidden":"true"}},[this._v("#")]),this._v(" 常见数据结构")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("基础学科内容，比如：网络知识、数据结构算法")]),this._v(" "),e("li",[this._v("编程思想")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("这一章节的内容信息量会很大，不适合在非电脑环境下阅读，请各位打开代码编辑器，一行行的敲代码，单纯阅读是学习不了数据结构的。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"时间复杂度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度","aria-hidden":"true"}},[this._v("#")]),this._v(" 时间复杂度")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#栈","aria-hidden":"true"}},[this._v("#")]),this._v(" 栈")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念","aria-hidden":"true"}},[this._v("#")]),this._v(" 概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/5/20/1637b785d2d68735?w=640&h=460&f=png&s=6932",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class Stack {\n  constructor() {\n    this.stack = []\n  }\n  push(item) {\n    this.stack.push(item)\n  }\n  pop() {\n    this.stack.pop()\n  }\n  peek() {\n    return this.stack[this.getCount() - 1]\n  }\n  getCount() {\n    return this.stack.length\n  }\n  isEmpty() {\n    return this.getCount() === 0\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用","aria-hidden":"true"}},[this._v("#")]),this._v(" 应用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("var isValid = function (s) {\n  let map = {\n    '(': -1,\n    ')': 1,\n    '[': -2,\n    ']': 2,\n    '{': -3,\n    '}': 3\n  }\n  let stack = []\n  for (let i = 0; i < s.length; i++) {\n    if (map[s[i]] < 0) {\n      stack.push(s[i])\n    } else {\n      let last = stack.pop()\n      if (map[last] + map[s[i]] != 0) return false\n    }\n  }\n  if (stack.length > 0) return false\n  return true\n};\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#队列","aria-hidden":"true"}},[this._v("#")]),this._v(" 队列")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"概念-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/5/20/1637cba2a6155793?w=640&h=419&f=png&s=15737",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"单链队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单链队列","aria-hidden":"true"}},[this._v("#")]),this._v(" 单链队列")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class Queue {\n  constructor() {\n    this.queue = []\n  }\n  enQueue(item) {\n    this.queue.push(item)\n  }\n  deQueue() {\n    return this.queue.shift()\n  }\n  getHeader() {\n    return this.queue[0]\n  }\n  getLength() {\n    return this.queue.length\n  }\n  isEmpty() {\n    return this.getLength() === 0\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"循环队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#循环队列","aria-hidden":"true"}},[this._v("#")]),this._v(" 循环队列")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class SqQueue {\n  constructor(length) {\n    this.queue = new Array(length + 1)\n    // 队头\n    this.first = 0\n    // 队尾\n    this.last = 0\n    // 当前队列大小\n    this.size = 0\n  }\n  enQueue(item) {\n    // 判断队尾 + 1 是否为队头\n    // 如果是就代表需要扩容数组\n    // % this.queue.length 是为了防止数组越界\n    if (this.first === (this.last + 1) % this.queue.length) {\n      this.resize(this.getLength() * 2 + 1)\n    }\n    this.queue[this.last] = item\n    this.size++\n    this.last = (this.last + 1) % this.queue.length\n  }\n  deQueue() {\n    if (this.isEmpty()) {\n      throw Error('Queue is empty')\n    }\n    let r = this.queue[this.first]\n    this.queue[this.first] = null\n    this.first = (this.first + 1) % this.queue.length\n    this.size--\n    // 判断当前队列大小是否过小\n    // 为了保证不浪费空间，在队列空间等于总长度四分之一时\n    // 且不为 2 时缩小总长度为当前的一半\n    if (this.size === this.getLength() / 4 && this.getLength() / 2 !== 0) {\n      this.resize(this.getLength() / 2)\n    }\n    return r\n  }\n  getHeader() {\n    if (this.isEmpty()) {\n      throw Error('Queue is empty')\n    }\n    return this.queue[this.first]\n  }\n  getLength() {\n    return this.queue.length - 1\n  }\n  isEmpty() {\n    return this.first === this.last\n  }\n  resize(length) {\n    let q = new Array(length)\n    for (let i = 0; i < length; i++) {\n      q[i] = this.queue[(i + this.first) % this.queue.length]\n    }\n    this.queue = q\n    this.first = 0\n    this.last = this.size\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表","aria-hidden":"true"}},[this._v("#")]),this._v(" 链表")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"概念-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念-3","aria-hidden":"true"}},[this._v("#")]),this._v(" 概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/5/22/16388487759b1152?w=1060&h=178&f=png&s=20820",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-3","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("单向链表")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class Node {\n  constructor(v, next) {\n    this.value = v\n    this.next = next\n  }\n}\nclass LinkList {\n  constructor() {\n    // 链表长度\n    this.size = 0\n    // 虚拟头部\n    this.dummyNode = new Node(null, null)\n  }\n  find(header, index, currentIndex) {\n    if (index === currentIndex) return header\n    return this.find(header.next, index, currentIndex + 1)\n  }\n  addNode(v, index) {\n    this.checkIndex(index)\n    // 当往链表末尾插入时，prev.next 为空\n    // 其他情况时，因为要插入节点，所以插入的节点\n    // 的 next 应该是 prev.next\n    // 然后设置 prev.next 为插入的节点\n    let prev = this.find(this.dummyNode, index, 0)\n    prev.next = new Node(v, prev.next)\n    this.size++\n    return prev.next\n  }\n  insertNode(v, index) {\n    return this.addNode(v, index)\n  }\n  addToFirst(v) {\n    return this.addNode(v, 0)\n  }\n  addToLast(v) {\n    return this.addNode(v, this.size)\n  }\n  removeNode(index, isLast) {\n    this.checkIndex(index)\n    index = isLast ? index - 1 : index\n    let prev = this.find(this.dummyNode, index, 0)\n    let node = prev.next\n    prev.next = node.next\n    node.next = null\n    this.size--\n    return node\n  }\n  removeFirstNode() {\n    return this.removeNode(0)\n  }\n  removeLastNode() {\n    return this.removeNode(this.size, true)\n  }\n  checkIndex(index) {\n    if (index < 0 || index > this.size) throw Error('Index error')\n  }\n  getNode(index) {\n    this.checkIndex(index)\n    if (this.isEmpty()) return\n    return this.find(this.dummyNode, index, 0).next\n  }\n  isEmpty() {\n    return this.size === 0\n  }\n  getSize() {\n    return this.size\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#树","aria-hidden":"true"}},[this._v("#")]),this._v(" 树")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树","aria-hidden":"true"}},[this._v("#")]),this._v(" 二叉树")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/5/22/163884f74c9f4e4d?w=320&h=267&f=png&s=11622",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"二分搜索树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二分搜索树","aria-hidden":"true"}},[this._v("#")]),this._v(" 二分搜索树")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/5/22/1638850ba7458208?w=596&h=485&f=png&s=36796",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-4","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class Node {\n  constructor(value) {\n    this.value = value\n    this.left = null\n    this.right = null\n  }\n}\nclass BST {\n  constructor() {\n    this.root = null\n    this.size = 0\n  }\n  getSize() {\n    return this.size\n  }\n  isEmpty() {\n    return this.size === 0\n  }\n  addNode(v) {\n    this.root = this._addChild(this.root, v)\n  }\n  // 添加节点时，需要比较添加的节点值和当前\n  // 节点值的大小\n  _addChild(node, v) {\n    if (!node) {\n      this.size++\n      return new Node(v)\n    }\n    if (node.value > v) {\n      node.left = this._addChild(node.left, v)\n    } else if (node.value < v) {\n      node.right = this._addChild(node.right, v)\n    }\n    return node\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("// 先序遍历可用于打印树的结构\n// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。\npreTraversal() {\n  this._pre(this.root)\n}\n_pre(node) {\n  if (node) {\n    console.log(node.value)\n    this._pre(node.left)\n    this._pre(node.right)\n  }\n}\n// 中序遍历可用于排序\n// 对于 BST 来说，中序遍历可以实现一次遍历就\n// 得到有序的值\n// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。\nmidTraversal() {\n  this._mid(this.root)\n}\n_mid(node) {\n  if (node) {\n    this._mid(node.left)\n    console.log(node.value)\n    this._mid(node.right)\n  }\n}\n// 后序遍历可用于先操作子节点\n// 再操作父节点的场景\n// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。\nbackTraversal() {\n  this._back(this.root)\n}\n_back(node) {\n  if (node) {\n    this._back(node.left)\n    this._back(node.right)\n    console.log(node.value)\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("breadthTraversal() {\n  if (!this.root) return null\n  let q = new Queue()\n  // 将根节点入队\n  q.enQueue(this.root)\n  // 循环判断队列是否为空，为空\n  // 代表树遍历完毕\n  while (!q.isEmpty()) {\n    // 将队首出队，判断是否有左右子树\n    // 有的话，就先左后右入队\n    let n = q.deQueue()\n    console.log(n.value)\n    if (n.left) q.enQueue(n.left)\n    if (n.right) q.enQueue(n.right)\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("getMin() {\n  return this._getMin(this.root).value\n}\n_getMin(node) {\n  if (!node.left) return node\n  return this._getMin(node.left)\n}\ngetMax() {\n  return this._getMax(this.root).value\n}\n_getMax(node) {\n  if (!node.right) return node\n  return this._getMin(node.right)\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("向上取整和向下取整")]),this._v("，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("floor(v) {\n  let node = this._floor(this.root, v)\n  return node ? node.value : null\n}\n_floor(node, v) {\n  if (!node) return null\n  if (node.value === v) return v\n  // 如果当前节点值还比需要的值大，就继续递归\n  if (node.value > v) {\n    return this._floor(node.left, v)\n  }\n  // 判断当前节点是否拥有右子树\n  let right = this._floor(node.right, v)\n  if (right) return right\n  return node\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("排名")]),this._v("，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 "),e("code",[this._v("size")]),this._v(" 属性。该属性表示该节点下有多少子节点（包含自身）。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class Node {\n  constructor(value) {\n    this.value = value\n    this.left = null\n    this.right = null\n    // 修改代码\n    this.size = 1\n  }\n}\n// 新增代码\n_getSize(node) {\n  return node ? node.size : 0\n}\n_addChild(node, v) {\n  if (!node) {\n    return new Node(v)\n  }\n  if (node.value > v) {\n    // 修改代码\n    node.size++\n    node.left = this._addChild(node.left, v)\n  } else if (node.value < v) {\n    // 修改代码\n    node.size++\n    node.right = this._addChild(node.right, v)\n  }\n  return node\n}\nselect(k) {\n  let node = this._select(this.root, k)\n  return node ? node.value : null\n}\n_select(node, k) {\n  if (!node) return null\n  // 先获取左子树下有几个节点\n  let size = node.left ? node.left.size : 0\n  // 判断 size 是否大于 k\n  // 如果大于 k，代表所需要的节点在左节点\n  if (size > k) return this._select(node.left, k)\n  // 如果小于 k，代表所需要的节点在右节点\n  // 注意这里需要重新计算 k，减去根节点除了右子树的节点数量\n  if (size < k) return this._select(node.right, k - size - 1)\n  return node\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("需要删除的节点没有子树")]),this._v(" "),e("li",[this._v("需要删除的节点只有一条子树")]),this._v(" "),e("li",[this._v("需要删除的节点有左右两条树")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("delectMin() {\n  this.root = this._delectMin(this.root)\n  console.log(this.root)\n}\n_delectMin(node) {\n  // 一直递归左子树\n  // 如果左子树为空，就判断节点是否拥有右子树\n  // 有右子树的话就把需要删除的节点替换为右子树\n  if ((node != null) & !node.left) return node.right\n  node.left = this._delectMin(node.left)\n  // 最后需要重新维护下节点的 `size`\n  node.size = this._getSize(node.left) + this._getSize(node.right) + 1\n  return node\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("delect(v) {\n  this.root = this._delect(this.root, v)\n}\n_delect(node, v) {\n  if (!node) return null\n  // 寻找的节点比当前节点小，去左子树找\n  if (node.value < v) {\n    node.right = this._delect(node.right, v)\n  } else if (node.value > v) {\n    // 寻找的节点比当前节点大，去右子树找\n    node.left = this._delect(node.left, v)\n  } else {\n    // 进入这个条件说明已经找到节点\n    // 先判断节点是否拥有拥有左右子树中的一个\n    // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样\n    if (!node.left) return node.right\n    if (!node.right) return node.left\n    // 进入这里，代表节点拥有左右子树\n    // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值\n    let min = this._getMin(node.right)\n    // 取出最小值后，删除最小值\n    // 然后把删除节点后的子树赋值给最小值节点\n    min.right = this._delectMin(node.right)\n    // 左子树不动\n    min.left = node.left\n    node = min\n  }\n  // 维护 size\n  node.size = this._getSize(node.left) + this._getSize(node.right) + 1\n  return node\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"avl-树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#avl-树","aria-hidden":"true"}},[this._v("#")]),this._v(" AVL 树")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"概念-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念-4","aria-hidden":"true"}},[this._v("#")]),this._v(" 概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-5","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/6/23/1642cc145a0cfb26?w=800&h=566&f=png&s=73573",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class Node {\n  constructor(value) {\n    this.value = value\n    this.left = null\n    this.right = null\n    this.height = 1\n  }\n}\n\nclass AVL {\n  constructor() {\n    this.root = null\n  }\n  addNode(v) {\n    this.root = this._addChild(this.root, v)\n  }\n  _addChild(node, v) {\n    if (!node) {\n      return new Node(v)\n    }\n    if (node.value > v) {\n      node.left = this._addChild(node.left, v)\n    } else if (node.value < v) {\n      node.right = this._addChild(node.right, v)\n    } else {\n      node.value = v\n    }\n    node.height =\n      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))\n    let factor = this._getBalanceFactor(node)\n    // 当需要右旋时，根节点的左树一定比右树高度高\n    if (factor > 1 && this._getBalanceFactor(node.left) >= 0) {\n      return this._rightRotate(node)\n    }\n    // 当需要左旋时，根节点的左树一定比右树高度矮\n    if (factor < -1 && this._getBalanceFactor(node.right) <= 0) {\n      return this._leftRotate(node)\n    }\n    // 左右情况\n    // 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高\n    if (factor > 1 && this._getBalanceFactor(node.left) < 0) {\n      node.left = this._leftRotate(node.left)\n      return this._rightRotate(node)\n    }\n    // 右左情况\n    // 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮\n    if (factor < -1 && this._getBalanceFactor(node.right) > 0) {\n      node.right = this._rightRotate(node.right)\n      return this._leftRotate(node)\n    }\n\n    return node\n  }\n  _getHeight(node) {\n    if (!node) return 0\n    return node.height\n  }\n  _getBalanceFactor(node) {\n    return this._getHeight(node.left) - this._getHeight(node.right)\n  }\n  // 节点右旋\n  //           5                    2\n  //         /   \\                /   \\\n  //        2     6   ==>       1      5\n  //       /  \\               /       /  \\\n  //      1    3             new     3    6\n  //     /\n  //    new\n  _rightRotate(node) {\n    // 旋转后新根节点\n    let newRoot = node.left\n    // 需要移动的节点\n    let moveNode = newRoot.right\n    // 节点 2 的右节点改为节点 5\n    newRoot.right = node\n    // 节点 5 左节点改为节点 3\n    node.left = moveNode\n    // 更新树的高度\n    node.height =\n      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))\n    newRoot.height =\n      1 +\n      Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right))\n\n    return newRoot\n  }\n  // 节点左旋\n  //           4                    6\n  //         /   \\                /   \\\n  //        2     6   ==>       4      7\n  //             /  \\         /   \\      \\\n  //            5     7      2     5      new\n  //                   \\\n  //                    new\n  _leftRotate(node) {\n    // 旋转后新根节点\n    let newRoot = node.right\n    // 需要移动的节点\n    let moveNode = newRoot.left\n    // 节点 6 的左节点改为节点 4\n    newRoot.left = node\n    // 节点 4 右节点改为节点 5\n    node.right = moveNode\n    // 更新树的高度\n    node.height =\n      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))\n    newRoot.height =\n      1 +\n      Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right))\n\n    return newRoot\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"trie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#trie","aria-hidden":"true"}},[this._v("#")]),this._v(" Trie")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"概念-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念-5","aria-hidden":"true"}},[this._v("#")]),this._v(" 概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在计算机科学，"),e("strong",[this._v("trie")]),this._v("，又称"),e("strong",[this._v("前缀树")]),this._v("或"),e("strong",[this._v("字典树")]),this._v("，是一种有序树，用于保存关联数组，其中的键通常是字符串。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("根节点代表空字符串，每个节点都有 N（假如搜索英文字符，就有 26 条） 条链接，每条链接代表一个字符")]),this._v(" "),e("li",[this._v("节点不存储字符，只有路径才存储，这点和其他的树结构不同")]),this._v(" "),e("li",[this._v("从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/6/9/163e1d2f6cec3348?w=640&h=600&f=png&s=48344",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-6","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class TrieNode {\n  constructor() {\n    // 代表每个字符经过节点的次数\n    this.path = 0\n    // 代表到该节点的字符串有几个\n    this.end = 0\n    // 链接\n    this.next = new Array(26).fill(null)\n  }\n}\nclass Trie {\n  constructor() {\n    // 根节点，代表空字符\n    this.root = new TrieNode()\n  }\n  // 插入字符串\n  insert(str) {\n    if (!str) return\n    let node = this.root\n    for (let i = 0; i < str.length; i++) {\n      // 获得字符先对应的索引\n      let index = str[i].charCodeAt() - 'a'.charCodeAt()\n      // 如果索引对应没有值，就创建\n      if (!node.next[index]) {\n        node.next[index] = new TrieNode()\n      }\n      node.path += 1\n      node = node.next[index]\n    }\n    node.end += 1\n  }\n  // 搜索字符串出现的次数\n  search(str) {\n    if (!str) return\n    let node = this.root\n    for (let i = 0; i < str.length; i++) {\n      let index = str[i].charCodeAt() - 'a'.charCodeAt()\n      // 如果索引对应没有值，代表没有需要搜素的字符串\n      if (!node.next[index]) {\n        return 0\n      }\n      node = node.next[index]\n    }\n    return node.end\n  }\n  // 删除字符串\n  delete(str) {\n    if (!this.search(str)) return\n    let node = this.root\n    for (let i = 0; i < str.length; i++) {\n      let index = str[i].charCodeAt() - 'a'.charCodeAt()\n      // 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串\n      // 已经一个，直接删除即可\n      if (--node.next[index].path == 0) {\n        node.next[index] = null\n        return\n      }\n      node = node.next[index]\n    }\n    node.end -= 1\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"并查集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并查集","aria-hidden":"true"}},[this._v("#")]),this._v(" 并查集")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"概念-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念-6","aria-hidden":"true"}},[this._v("#")]),this._v(" 概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。")]),this._v(" "),e("li",[this._v("Union：将两个子集合并成同一个集合。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/6/9/163e45b56fd25172?w=421&h=209&f=png&s=26545",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-7","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class DisjointSet {\n  // 初始化样本\n  constructor(count) {\n    // 初始化时，每个节点的父节点都是自己\n    this.parent = new Array(count)\n    // 用于记录树的深度，优化搜索复杂度\n    this.rank = new Array(count)\n    for (let i = 0; i < count; i++) {\n      this.parent[i] = i\n      this.rank[i] = 1\n    }\n  }\n  find(p) {\n    // 寻找当前节点的父节点是否为自己，不是的话表示还没找到\n    // 开始进行路径压缩优化\n    // 假设当前节点父节点为 A\n    // 将当前节点挂载到 A 节点的父节点上，达到压缩深度的目的\n    while (p != this.parent[p]) {\n      this.parent[p] = this.parent[this.parent[p]]\n      p = this.parent[p]\n    }\n    return p\n  }\n  isConnected(p, q) {\n    return this.find(p) === this.find(q)\n  }\n  // 合并\n  union(p, q) {\n    // 找到两个数字的父节点\n    let i = this.find(p)\n    let j = this.find(q)\n    if (i === j) return\n    // 判断两棵树的深度，深度小的加到深度大的树下面\n    // 如果两棵树深度相等，那就无所谓怎么加\n    if (this.rank[i] < this.rank[j]) {\n      this.parent[i] = j\n    } else if (this.rank[i] > this.rank[j]) {\n      this.parent[j] = i\n    } else {\n      this.parent[i] = j\n      this.rank[j] += 1\n    }\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"堆"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆","aria-hidden":"true"}},[this._v("#")]),this._v(" 堆")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"概念-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念-7","aria-hidden":"true"}},[this._v("#")]),this._v(" 概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("堆的实现通过构造"),e("strong",[this._v("二叉堆")]),this._v("，实为二叉树的一种。这种数据结构具有以下性质。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("任意节点小于（或大于）它的所有子节点")]),this._v(" "),e("li",[this._v("堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[t._v("将根节点最大的堆叫做"),n("strong",[t._v("最大堆")]),t._v("或"),n("strong",[t._v("大根堆")]),t._v("，根节点最小的堆叫做"),n("strong",[t._v("最小堆")]),t._v("或"),n("strong",[t._v("小根堆")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现大根堆"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现大根堆","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现大根堆")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("堆的每个节点的左边子节点索引是 "),e("code",[this._v("i * 2 + 1")]),this._v("，右边是 "),e("code",[this._v("i * 2 + 2")]),this._v("，父节点是 "),e("code",[this._v("(i - 1) /2")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("堆有两个核心的操作，分别是 "),e("code",[this._v("shiftUp")]),this._v(" 和 "),e("code",[this._v("shiftDown")]),this._v(" 。前者用于添加元素，后者用于删除根节点。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("shiftUp")]),this._v(" 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("shiftDown")]),this._v(" 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/6/15/164009e58a5a21f8?w=537&h=394&f=png&s=77222",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n  size() {\n    return this.heap.length\n  }\n  empty() {\n    return this.size() == 0\n  }\n  add(item) {\n    this.heap.push(item)\n    this._shiftUp(this.size() - 1)\n  }\n  removeMax() {\n    this._shiftDown(0)\n  }\n  getParentIndex(k) {\n    return parseInt((k - 1) / 2)\n  }\n  getLeftIndex(k) {\n    return k * 2 + 1\n  }\n  _shiftUp(k) {\n    // 如果当前节点比父节点大，就交换\n    while (this.heap[k] > this.heap[this.getParentIndex(k)]) {\n      this._swap(k, this.getParentIndex(k))\n      // 将索引变成父节点\n      k = this.getParentIndex(k)\n    }\n  }\n  _shiftDown(k) {\n    // 交换首位并删除末尾\n    this._swap(k, this.size() - 1)\n    this.heap.splice(this.size() - 1, 1)\n    // 判断节点是否有左孩子，因为二叉堆的特性，有右必有左\n    while (this.getLeftIndex(k) < this.size()) {\n      let j = this.getLeftIndex(k)\n      // 判断是否有右孩子，并且右孩子是否大于左孩子\n      if (j + 1 < this.size() && this.heap[j + 1] > this.heap[j]) j++\n      // 判断父节点是否已经比子节点都大\n      if (this.heap[k] >= this.heap[j]) break\n      this._swap(k, j)\n      k = j\n    }\n  }\n  _swap(left, right) {\n    let rightValue = this.heap[right]\n    this.heap[right] = this.heap[left]\n    this.heap[left] = rightValue\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[this._v("#")]),this._v(" 小结")])}],!1,null,null,null);e.default=r.exports}}]);