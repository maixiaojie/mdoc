(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{182:function(t,e,_){"use strict";_.r(e);var i=_(0),s=Object(i.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),_("p",[t._v("这一章节我们将来学习 Vue 的一些经常考到的基础知识点。")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),_("p",[t._v("组件通信一般分为以下几种情况：")]),t._v(" "),t._m(9),t._v(" "),_("p",[t._v("对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。")]),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),_("p",[t._v("假设有父组件 A，然后有一个跨多层级的子组件 B")]),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),_("p",[t._v("这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况")]),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),_("p",[t._v("另外需要注意的是 "),_("code",[t._v("mixins")]),t._v(" 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 "),_("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/mixins.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("文档"),_("OutboundLink")],1),t._v("。")]),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),t._m(42),t._v(" "),t._m(43),t._v(" "),t._m(44),t._v(" "),t._m(45),t._v(" "),t._m(46),t._v(" "),_("p",[t._v("这道题目其实更多考的是 JS 功底。")]),t._v(" "),t._m(47),t._v(" "),t._m(48),t._v(" "),t._m(49),t._v(" "),_("p",[t._v("总的来说这一章节的内容更多的偏向于 Vue 的基础，下一章节我们将来了解一些原理性方面的知识。")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"vue-常考基础知识点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-常考基础知识点","aria-hidden":"true"}},[this._v("#")]),this._v(" Vue 常考基础知识点")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"生命周期钩子函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子函数","aria-hidden":"true"}},[this._v("#")]),this._v(" 生命周期钩子函数")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("在 "),_("code",[t._v("beforeCreate")]),t._v(" 钩子函数调用的时候，是获取不到 "),_("code",[t._v("props")]),t._v(" 或者 "),_("code",[t._v("data")]),t._v(" 中的数据的，因为这些数据的初始化都在 "),_("code",[t._v("initState")]),t._v(" 中。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("然后会执行 "),e("code",[this._v("created")]),this._v(" 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("接下来会先执行 "),e("code",[this._v("beforeMount")]),this._v(" 钩子函数，开始创建 VDOM，最后执行 "),e("code",[this._v("mounted")]),this._v(" 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("接下来是数据更新时会调用的钩子函数 "),e("code",[this._v("beforeUpdate")]),this._v(" 和 "),e("code",[this._v("updated")]),this._v("，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("另外还有 "),_("code",[t._v("keep-alive")]),t._v(" 独有的生命周期，分别为 "),_("code",[t._v("activated")]),t._v(" 和 "),_("code",[t._v("deactivated")]),t._v(" 。用 "),_("code",[t._v("keep-alive")]),t._v(" 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 "),_("code",[t._v("deactivated")]),t._v(" 钩子函数，命中缓存渲染后会执行 "),_("code",[t._v("actived")]),t._v(" 钩子函数。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("最后就是销毁组件的钩子函数 "),e("code",[this._v("beforeDestroy")]),this._v(" 和 "),e("code",[this._v("destroyed")]),this._v("。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 "),e("code",[this._v("destroyed")]),this._v(" 钩子函数。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件通信","aria-hidden":"true"}},[this._v("#")]),this._v(" 组件通信")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("父子组件通信")]),this._v(" "),e("li",[this._v("兄弟组件通信")]),this._v(" "),e("li",[this._v("跨多层级组件通信")]),this._v(" "),e("li",[this._v("任意组件")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"父子通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父子通信","aria-hidden":"true"}},[this._v("#")]),this._v(" 父子通信")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("父组件通过 "),e("code",[this._v("props")]),this._v(" 传递数据给子组件，子组件通过 "),e("code",[this._v("emit")]),this._v(" 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这种父子通信方式也就是典型的单向数据流，父组件通过 "),e("code",[this._v("props")]),this._v(" 传递数据，子组件不能直接修改 "),e("code",[this._v("props")]),this._v("， 而是必须通过发送事件的方式告知父组件修改数据。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("另外这两种方式还可以使用语法糖 "),_("code",[t._v("v-model")]),t._v(" 来直接实现，因为 "),_("code",[t._v("v-model")]),t._v(" 默认会解析成名为 "),_("code",[t._v("value")]),t._v(" 的 "),_("code",[t._v("prop")]),t._v(" 和名为 "),_("code",[t._v("input")]),t._v(" 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当然我们还可以通过访问 "),e("code",[this._v("$parent")]),this._v(" 或者 "),e("code",[this._v("$children")]),this._v(" 对象来访问组件实例中的方法和数据。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("另外如果你使用 Vue 2.3 及以上版本的话还可以使用 "),e("code",[this._v("$listeners")]),this._v(" 和 "),e("code",[this._v(".sync")]),this._v(" 这两个属性。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[_("code",[t._v("$listeners")]),t._v(" 属性会将父组件中的 (不含 "),_("code",[t._v(".native")]),t._v(" 修饰器的) "),_("code",[t._v("v-on")]),t._v(" 事件监听器传递给子组件，子组件可以通过访问 "),_("code",[t._v("$listeners")]),t._v(" 来自定义监听器。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v(".sync")]),this._v(" 属性是个语法糖，可以很简单的实现子组件与父组件通信")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v('\x3c!--父组件中--\x3e\n<input :value.sync="value" />\n\x3c!--以上写法等同于--\x3e\n<input :value="value" @update:value="v => value = v"></comp>\n\x3c!--子组件中--\x3e\n<script>\n  this.$emit(\'update:value\', 1)\n<\/script>\n')])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"兄弟组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#兄弟组件通信","aria-hidden":"true"}},[this._v("#")]),this._v(" 兄弟组件通信")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对于这种情况可以通过查找父组件中的子组件实现，也就是 "),e("code",[this._v("this.$parent.$children")]),this._v("，在 "),e("code",[this._v("$children")]),this._v(" 中可以通过组件 "),e("code",[this._v("name")]),this._v(" 查询到需要的组件实例，然后进行通信。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"跨多层次组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跨多层次组件通信","aria-hidden":"true"}},[this._v("#")]),this._v(" 跨多层次组件通信")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对于这种情况可以使用 Vue 2.2 新增的 API "),e("code",[this._v("provide / inject")]),this._v("，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("// 父组件 A\nexport default {\n  provide: {\n    data: 1\n  }\n}\n// 子组件 B\nexport default {\n  inject: ['data'],\n  mounted() {\n    // 无论跨几层都能获得父组件的 data 属性\n    console.log(this.data) // => 1\n  }\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"任意组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#任意组件","aria-hidden":"true"}},[this._v("#")]),this._v(" 任意组件")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"extend-能做什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#extend-能做什么","aria-hidden":"true"}},[this._v("#")]),this._v(" extend 能做什么")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 "),e("code",[this._v("$mount")]),this._v(" 一起使用。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("// 创建组件构造器\nlet Component = Vue.extend({\n  template: '<div>test</div>'\n})\n// 挂载到 #app 上\nnew Component().$mount('#app')\n// 除了上面的方式，还可以用来扩展已有的组件\nlet SuperComponent = Vue.extend(Component)\nnew SuperComponent({\n    created() {\n        console.log(1)\n    }\n})\nnew SuperComponent().$mount('#app')\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"mixin-和-mixins-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mixin-和-mixins-区别","aria-hidden":"true"}},[this._v("#")]),this._v(" mixin 和 mixins 区别")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("mixin")]),this._v(" 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("Vue.mixin({\n    beforeCreate() {\n        // ...逻辑\n        // 这种方式会影响到每个组件的 beforeCreate 钩子函数\n    }\n})\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("虽然文档不建议我们在应用中直接使用 "),e("code",[this._v("mixin")]),this._v("，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 "),e("code",[this._v("ajax")]),this._v(" 或者一些工具函数等等。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("mixins")]),this._v(" 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 "),e("code",[this._v("mixins")]),this._v(" 混入代码，比如上拉下拉加载数据这种逻辑等等。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"computed-和-watch-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-区别","aria-hidden":"true"}},[this._v("#")]),this._v(" computed 和 watch 区别")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("computed")]),this._v(" 是计算属性，依赖其他属性计算值，并且 "),e("code",[this._v("computed")]),this._v(" 的值有缓存，只有当计算值变化才会返回内容。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("watch")]),this._v(" 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("所以一般来说需要依赖别的属性来动态获得值的时候可以使用 "),e("code",[this._v("computed")]),this._v("，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 "),e("code",[this._v("watch")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("另外 "),e("code",[this._v("computed")]),this._v(" 和 "),e("code",[this._v("watch")]),this._v(" 还都支持对象的写法，这种方式知道的人并不多。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("vm.$watch('obj', {\n    // 深度遍历\n    deep: true,\n    // 立即触发\n    immediate: true,\n    // 执行的函数\n    handler: function(val, oldVal) {}\n})\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    aPlus: {\n      // this.aPlus 时触发\n      get: function () {\n        return this.a + 1\n      },\n      // this.aPlus = 1 时触发\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"keep-alive-组件有什么作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-组件有什么作用","aria-hidden":"true"}},[this._v("#")]),this._v(" keep-alive 组件有什么作用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 "),e("code",[this._v("keep-alive")]),this._v(" 组件包裹需要保存的组件。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("对于 "),_("code",[t._v("keep-alive")]),t._v(" 组件来说，它拥有两个独有的生命周期钩子函数，分别为 "),_("code",[t._v("activated")]),t._v(" 和 "),_("code",[t._v("deactivated")]),t._v(" 。用 "),_("code",[t._v("keep-alive")]),t._v(" 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 "),_("code",[t._v("deactivated")]),t._v(" 钩子函数，命中缓存渲染后会执行 "),_("code",[t._v("actived")]),t._v(" 钩子函数。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"v-show-与-v-if-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-show-与-v-if-区别","aria-hidden":"true"}},[this._v("#")]),this._v(" v-show 与 v-if 区别")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[_("code",[t._v("v-show")]),t._v(" 只是在 "),_("code",[t._v("display: none")]),t._v(" 和 "),_("code",[t._v("display: block")]),t._v(" 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 "),_("code",[t._v("v-show")]),t._v(" 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("v-if")]),this._v(" 的话就得说到 Vue 底层的编译了。当属性初始为 "),e("code",[this._v("false")]),this._v(" 时，组件就不会被渲染，直到条件为 "),e("code",[this._v("true")]),this._v("，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("并且基于 "),e("code",[this._v("v-if")]),this._v(" 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"组件中-data-什么时候可以使用对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件中-data-什么时候可以使用对象","aria-hidden":"true"}},[this._v("#")]),this._v(" 组件中 data 什么时候可以使用对象")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("组件复用时所有组件实例都会共享 "),_("code",[t._v("data")]),t._v("，如果 "),_("code",[t._v("data")]),t._v(" 是对象的话，就会造成一个组件修改 "),_("code",[t._v("data")]),t._v(" 以后会影响到其他所有组件，所以需要将 "),_("code",[t._v("data")]),t._v(" 写成函数，每次用到就调用一次函数获得新的数据。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("当我们使用 "),_("code",[t._v("new Vue()")]),t._v(" 的方式的时候，无论我们将 "),_("code",[t._v("data")]),t._v(" 设置为对象还是函数都是可以的，因为 "),_("code",[t._v("new Vue()")]),t._v(" 的方式是生成一个根组件，该组件不会复用，也就不存在共享 "),_("code",[t._v("data")]),t._v(" 的情况了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[this._v("#")]),this._v(" 小结")])}],!1,null,null,null);e.default=s.exports}}]);