(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{177:function(e,t,n){"use strict";n.r(t);var r=n(0),s=Object(r.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[e._m(0),e._v(" "),n("p",[e._v("设计模式总的来说是一个抽象的概念，前人通过无数次的实践总结出的一套写代码的方式，通过这种方式写的代码可以让别人更加容易阅读、维护以及复用。")]),e._v(" "),n("p",[e._v("这一章节我们将来学习几种最常用的设计模式。")]),e._v(" "),e._m(1),e._v(" "),n("p",[e._v("工厂模式分为好几种，这里就不一一讲解了，以下是一个简单工厂模式的例子")]),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),n("p",[e._v("可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。")]),e._v(" "),n("p",[e._v("工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。")]),e._v(" "),n("p",[e._v("在 Vue 源码中，你也可以看到工厂模式的使用，比如创建异步组件")]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),n("p",[e._v("单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。")]),e._v(" "),n("p",[e._v("单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式并不能套入 JS 中，我们只需要用一个变量确保实例只创建一次就行，以下是如何实现单例模式的例子")]),e._v(" "),e._m(7),e._v(" "),n("p",[e._v("在 Vuex 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 Vuex")]),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),n("p",[e._v("适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。")]),e._v(" "),n("p",[e._v("以下是如何实现适配器模式的例子")]),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),n("p",[e._v("装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。")]),e._v(" "),n("p",[e._v("以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法")]),e._v(" "),e._m(13),e._v(" "),n("p",[e._v("在 React 中，装饰模式其实随处可见")]),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),n("p",[e._v("代理是为了控制对对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理的场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品。")]),e._v(" "),n("p",[e._v("在实际代码中其实代理的场景很多，也就不举框架中的例子了，比如事件代理就用到了代理模式。")]),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),n("p",[e._v("发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。")]),e._v(" "),n("p",[e._v("在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式")]),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),n("p",[e._v("外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。")]),e._v(" "),n("p",[e._v("举个例子来说，我们现在需要实现一个兼容多种浏览器的添加事件方法")]),e._v(" "),e._m(22),e._v(" "),e._m(23),e._v(" "),e._m(24),e._v(" "),n("p",[e._v("这一章节我们学习了几种常用的设计模式。其实设计模式还有很多，有一些内容很简单，我就没有写在章节中了，比如迭代器模式、原型模式，有一些内容也是不经常使用，所以也就不一一列举了。")]),e._v(" "),n("p",[e._v("如果你还想了解更多关于设计模式的内容，可以阅读"),n("a",{attrs:{href:"https://book.douban.com/subject/26382780/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这本书"),n("OutboundLink")],1),e._v("。")])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 设计模式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 工厂模式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("class Man {\n  constructor(name) {\n    this.name = name\n  }\n  alertName() {\n    alert(this.name)\n  }\n}\n\nclass Factory {\n  static create(name) {\n    return new Man(name)\n  }\n}\n\nFactory.create('yck').alertName()\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("当然工厂模式并不仅仅是用来 new 出"),t("strong",[this._v("实例")]),this._v("。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("export function createComponent (\n  Ctor: Class<Component> | Function | Object | void,\n  data: ?VNodeData,\n  context: Component,\n  children: ?Array<VNode>,\n  tag?: string\n): VNode | Array<VNode> | void {\n    \n    // 逻辑处理...\n  \n  const vnode = new VNode(\n    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,\n    data, undefined, undefined, undefined, context,\n    { Ctor, propsData, listeners, tag, children },\n    asyncFactory\n  )\n\n  return vnode\n}\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在上述代码中，我们可以看到我们只需要调用 "),t("code",[this._v("createComponent")]),this._v(" 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 单例模式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("class Singleton {\n  constructor() {}\n}\n\nSingleton.getInstance = (function() {\n  let instance\n  return function() {\n    if (!instance) {\n      instance = new Singleton()\n    }\n    return instance\n  }\n})()\n\nlet s1 = Singleton.getInstance()\nlet s2 = Singleton.getInstance()\nconsole.log(s1 === s2) // true\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("let Vue // bind on install\n\nexport function install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    // 如果发现 Vue 有值，就不重新创建实例了\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"适配器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 适配器模式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("class Plug {\n  getName() {\n    return '港版插头'\n  }\n}\n\nclass Target {\n  constructor() {\n    this.plug = new Plug()\n  }\n  getName() {\n    return this.plug.getName() + ' 适配器转二脚插头'\n  }\n}\n\nlet target = new Target()\ntarget.getName() // 港版插头 适配器转二脚插头\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在 Vue 中，我们其实经常使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 "),t("code",[this._v("computed")]),this._v(" 来做转换这件事情，这个过程就使用到了适配器模式。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"装饰模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#装饰模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 装饰模式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("function readonly(target, key, descriptor) {\n  descriptor.writable = false\n  return descriptor\n}\n\nclass Test {\n  @readonly\n  name = 'yck'\n}\n\nlet t = new Test()\n\nt.yck = '111' // 不可修改\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("import { connect } from 'react-redux'\nclass MyComponent extends React.Component {\n    // ...\n}\nexport default connect(mapStateToProps)(MyComponent)\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"代理模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 代理模式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("<ul id=\"ul\">\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n</ul>\n<script>\n    let ul = document.querySelector('#ul')\n    ul.addEventListener('click', (event) => {\n        console.log(event.target);\n    })\n<\/script>\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("因为存在太多的 "),t("code",[this._v("li")]),this._v("，不可能每个都去绑定事件。这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"发布-订阅模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 发布-订阅模式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v("<ul id=\"ul\"></ul>\n<script>\n    let ul = document.querySelector('#ul')\n    ul.addEventListener('click', (event) => {\n        console.log(event.target);\n    })\n<\/script>\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在 Vue 中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 "),t("code",[this._v("get")]),this._v(" 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"外观模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外观模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 外观模式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",[this._v('function addEvent(elm, evType, fn, useCapture) {\n  if (elm.addEventListener) {\n    elm.addEventListener(evType, fn, useCapture)\n    return true\n  } else if (elm.attachEvent) {\n    var r = elm.attachEvent("on" + evType, fn)\n    return r\n  } else {\n    elm["on" + evType] = fn\n  }\n}\n')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("对于不同的浏览器，添加事件的方式可能会存在兼容问题。如果每次都需要去这样写一遍的话肯定是不能接受的，所以我们将这些判断逻辑统一封装在一个接口中，外部需要添加事件只需要调用 "),t("code",[this._v("addEvent")]),this._v(" 即可。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[this._v("#")]),this._v(" 小结")])}],!1,null,null,null);t.default=s.exports}}]);