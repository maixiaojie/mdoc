(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{195:function(e,n,t){"use strict";t.r(n);var r=t(0),s=Object(r.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[e._m(0),e._v(" "),t("p",[e._v("原本小册计划中是没有这一章节的，Webpack 工作原理应该是上一章节包含的内容。但是考虑到既然讲到工作原理，必然需要讲解源码，但是 Webpack 的源码很难读，不结合源码干巴巴讲原理又没有什么价值。所以在这一章节中，我将会带大家来实现一个几十行的迷你打包工具，该工具可以实现以下两个功能")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),t("p",[e._v("因为涉及到 ES6 转 ES5，所以我们首先需要安装一些 Babel 相关的工具")]),e._v(" "),e._m(4),e._v(" "),t("p",[e._v("接下来我们将这些工具引入文件中")]),e._v(" "),e._m(5),e._v(" "),t("p",[e._v("首先，我们先来实现如何使用 Babel 转换代码")]),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),t("p",[e._v("接下来我们需要实现一个函数，这个函数的功能有以下几点")]),e._v(" "),e._m(8),e._v(" "),t("p",[e._v("现在我们已经获取到了所有的依赖文件，接下来就是实现打包的功能了")]),e._v(" "),e._m(9),e._v(" "),t("p",[e._v("这段代码需要结合着 Babel 转换后的代码来看，这样大家就能理解为什么需要这样写了")]),e._v(" "),e._m(10),e._v(" "),t("p",[e._v("Babel 将我们 ES6 的模块化代码转换为了 CommonJS（如果你不熟悉 CommonJS 的话，可以阅读这一章节中关于 "),t("a",{attrs:{href:"https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d83f265da615f76ba57",target:"_blank",rel:"noopener noreferrer"}},[e._v("模块化的知识点"),t("OutboundLink")],1),e._v("） 的代码，但是浏览器是不支持 CommonJS 的，所以如果这段代码需要在浏览器环境下运行的话，我们需要自己实现 CommonJS 相关的代码，这就是 "),t("code",[e._v("bundle")]),e._v(" 函数做的大部分事情。")]),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),t("p",[e._v("如果你对于上面的实现还有疑惑的话，可以阅读下打包后的部分简化代码")]),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),t("p",[e._v("虽然实现这个工具只写了不到 100 行的代码，但是打包工具的核心原理就是这些了")]),e._v(" "),e._m(15),e._v(" "),t("p",[e._v("如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。")])])},[function(){var e=this.$createElement,n=this._self._c||e;return n("h1",{attrs:{id:"实现小型打包工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现小型打包工具","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现小型打包工具")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ul",[n("li",[this._v("将 ES6 转换为 ES5")]),this._v(" "),n("li",[this._v("支持在 JS 文件中 "),n("code",[this._v("import")]),this._v(" CSS 文件")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("通过这个工具的实现，大家可以理解到打包工具的"),n("strong",[this._v("原理")]),this._v("到底是什么。")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("yarn add babylon babel-traverse babel-core babel-preset-env  \n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("const fs = require('fs')\nconst path = require('path')\nconst babylon = require('babylon')\nconst traverse = require('babel-traverse').default\nconst { transformFromAst } = require('babel-core')\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("function readCode(filePath) {\n  // 读取文件内容\n  const content = fs.readFileSync(filePath, 'utf-8')\n  // 生成 AST\n  const ast = babylon.parse(content, {\n    sourceType: 'module'\n  })\n  // 寻找当前文件的依赖关系\n  const dependencies = []\n  traverse(ast, {\n    ImportDeclaration: ({ node }) => {\n      dependencies.push(node.source.value)\n    }\n  })\n  // 通过 AST 将代码转为 ES5\n  const { code } = transformFromAst(ast, null, {\n    presets: ['env']\n  })\n  return {\n    filePath,\n    dependencies,\n    code\n  }\n}\n")])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ul",[t("li",[e._v("首先我们传入一个文件路径参数，然后通过 "),t("code",[e._v("fs")]),e._v(" 将文件中的内容读取出来")]),e._v(" "),t("li",[e._v("接下来我们通过 "),t("code",[e._v("babylon")]),e._v(" 解析代码获取 AST，目的是为了分析代码中是否还引入了别的文件")]),e._v(" "),t("li",[e._v("通过 "),t("code",[e._v("dependencies")]),e._v(" 来存储文件中的依赖，然后再将 AST 转换为 ES5 代码")]),e._v(" "),t("li",[e._v("最后函数返回了一个对象，对象中包含了当前文件路径、当前文件依赖和当前文件转换后的代码")])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ul",[t("li",[t("p",[e._v("调用 "),t("code",[e._v("readCode")]),e._v(" 函数，传入入口文件")])]),e._v(" "),t("li",[t("p",[e._v("分析入口文件的依赖")])]),e._v(" "),t("li",[t("p",[e._v("识别 JS 和 CSS 文件")]),e._v(" "),t("p",[e._v("function getDependencies(entry) {\n// 读取入口文件\nconst entryObject = readCode(entry)\nconst dependencies = [entryObject]\n// 遍历所有文件依赖关系\nfor (const asset of dependencies) {\n// 获得文件目录\nconst dirname = path.dirname(asset.filePath)\n// 遍历当前文件依赖关系\nasset.dependencies.forEach(relativePath => {\n// 获得绝对路径\nconst absolutePath = path.join(dirname, relativePath)\n// CSS 文件逻辑就是将代码插入到 "),t("code",[e._v("style")]),e._v(" 标签中\nif (/.css$/.test(absolutePath)) {\nconst content = fs.readFileSync(absolutePath, 'utf-8')\nconst code = "),t("code",[e._v("const style = document.createElement('style') style.innerText = ${JSON.stringify(content).replace(/\\\\r\\\\n/g, '')} document.head.appendChild(style)")]),e._v("\ndependencies.push({\nfilePath: absolutePath,\nrelativePath,\ndependencies: [],\ncode\n})\n} else {\n// JS 代码需要继续查找是否有依赖关系\nconst child = readCode(absolutePath)\nchild.relativePath = relativePath\ndependencies.push(child)\n}\n})\n}\nreturn dependencies\n}")])]),e._v(" "),t("li",[t("p",[e._v("首先我们读取入口文件，然后创建一个数组，该数组的目的是存储代码中涉及到的所有文件")])]),e._v(" "),t("li",[t("p",[e._v("接下来我们遍历这个数组，一开始这个数组中只有入口文件，在遍历的过程中，如果入口文件有依赖其他的文件，那么就会被 "),t("code",[e._v("push")]),e._v(" 到这个数组中")])]),e._v(" "),t("li",[t("p",[e._v("在遍历的过程中，我们先获得该文件对应的目录，然后遍历当前文件的依赖关系")])]),e._v(" "),t("li",[t("p",[e._v("在遍历当前文件依赖关系的过程中，首先生成依赖文件的绝对路径，然后判断当前文件是 CSS 文件还是 JS 文件")]),e._v(" "),t("ul",[t("li",[e._v("如果是 CSS 文件的话，我们就不能用 Babel 去编译了，只需要读取 CSS 文件中的代码，然后创建一个 "),t("code",[e._v("style")]),e._v(" 标签，将代码插入进标签并且放入 "),t("code",[e._v("head")]),e._v(" 中即可")]),e._v(" "),t("li",[e._v("如果是 JS 文件的话，我们还需要分析 JS 文件是否还有别的依赖关系")]),e._v(" "),t("li",[e._v("最后将读取文件后的对象 "),t("code",[e._v("push")]),e._v(" 进数组中")])])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("function bundle(dependencies, entry) {\n  let modules = ''\n  // 构建函数参数，生成的结构为\n  // { './entry.js': function(module, exports, require) { 代码 } }\n  dependencies.forEach(dep => {\n    const filePath = dep.relativePath || entry\n    modules += `'${filePath}': (\n      function (module, exports, require) { ${dep.code} }\n    ),`\n  })\n  // 构建 require 函数，目的是为了获取模块暴露出来的内容\n  const result = `\n    (function(modules) {\n      function require(id) {\n        const module = { exports : {} }\n        modules[id](module, module.exports, require)\n        return module.exports\n      }\n      require('${entry}')\n    })({${modules}})\n  `\n  // 当生成的内容写入到文件中\n  fs.writeFileSync('./bundle.js', result)\n}\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("// entry.js\nvar _a = require('./a.js')\nvar _a2 = _interopRequireDefault(_a)\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj }\n}\nconsole.log(_a2.default)\n// a.js\nObject.defineProperty(exports, '__esModule', {\n    value: true\n})\nvar a = 1\nexports.default = a\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("接下来我们再来逐行解析 "),n("code",[this._v("bundle")]),this._v(" 函数")])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ul",[t("li",[e._v("首先遍历所有依赖文件，构建出一个函数参数对象")]),e._v(" "),t("li",[e._v("对象的属性就是当前文件的相对路径，属性值是一个函数，函数体是当前文件下的代码，函数接受三个参数 "),t("code",[e._v("module")]),e._v("、"),t("code",[e._v("exports")]),e._v("、 "),t("code",[e._v("require")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("module")]),e._v(" 参数对应 CommonJS 中的 "),t("code",[e._v("module")])]),e._v(" "),t("li",[t("code",[e._v("exports")]),e._v(" 参数对应 CommonJS 中的 "),t("code",[e._v("module.export")])]),e._v(" "),t("li",[t("code",[e._v("require")]),e._v(" 参数对应我们自己创建的 "),t("code",[e._v("require")]),e._v(" 函数")])])]),e._v(" "),t("li",[e._v("接下来就是构造一个使用参数的函数了，函数做的事情很简单，就是内部创建一个 "),t("code",[e._v("require")]),e._v(" 函数，然后调用 "),t("code",[e._v("require(entry)")]),e._v("，也就是 "),t("code",[e._v("require('./entry.js')")]),e._v("，这样就会从函数参数中找到 "),t("code",[e._v("./entry.js")]),e._v(" 对应的函数并执行，最后将导出的内容通过 "),t("code",[e._v("module.export")]),e._v(" 的方式让外部获取到")]),e._v(" "),t("li",[e._v("最后再将打包出来的内容写入到单独的文件中")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v(";(function(modules) {\n  function require(id) {\n    // 构造一个 CommonJS 导出代码\n    const module = { exports: {} }\n    // 去参数中获取文件对应的函数并执行\n    modules[id](module, module.exports, require)\n    return module.exports\n  }\n  require('./entry.js')\n})({\n  './entry.js': function(module, exports, require) {\n    // 这里继续通过构造的 require 去找到 a.js 文件对应的函数\n    var _a = require('./a.js')\n    console.log(_a2.default)\n  },\n  './a.js': function(module, exports, require) {\n    var a = 1\n    // 将 require 函数中的变量 module 变成了这样的结构\n    // module.exports = 1\n    // 这样就能在外部取到导出的内容了\n    exports.default = a\n  }\n  // 省略\n})\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("h2",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[this._v("#")]),this._v(" 小结")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ol",[n("li",[this._v("找出入口文件所有的依赖关系")]),this._v(" "),n("li",[this._v("然后通过构建 CommonJS 代码来获取 "),n("code",[this._v("exports")]),this._v(" 导出的内容")])])}],!1,null,null,null);n.default=s.exports}}]);