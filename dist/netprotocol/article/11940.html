<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>路由配置组件Felix | 趣谈网络协议</title>
    <meta name="description" content="Talking about Network Protocol">
    <link rel="icon" href="/netprotocol/logo.png">
    
    <link rel="preload" href="/netprotocol/assets/css/0.styles.8ed81d4f.css" as="style"><link rel="preload" href="/netprotocol/assets/js/app.a42fbc22.js" as="script"><link rel="preload" href="/netprotocol/assets/js/15.bba6998c.js" as="script"><link rel="prefetch" href="/netprotocol/assets/js/10.b137334e.js"><link rel="prefetch" href="/netprotocol/assets/js/11.f81a1afe.js"><link rel="prefetch" href="/netprotocol/assets/js/12.a3d3f02e.js"><link rel="prefetch" href="/netprotocol/assets/js/13.6f45434d.js"><link rel="prefetch" href="/netprotocol/assets/js/14.4373e971.js"><link rel="prefetch" href="/netprotocol/assets/js/16.fda5f416.js"><link rel="prefetch" href="/netprotocol/assets/js/17.8b2ce630.js"><link rel="prefetch" href="/netprotocol/assets/js/18.39838a6e.js"><link rel="prefetch" href="/netprotocol/assets/js/19.ced40dbf.js"><link rel="prefetch" href="/netprotocol/assets/js/2.5e23b1e3.js"><link rel="prefetch" href="/netprotocol/assets/js/20.dc1009fb.js"><link rel="prefetch" href="/netprotocol/assets/js/21.18ac33b5.js"><link rel="prefetch" href="/netprotocol/assets/js/22.f92681cb.js"><link rel="prefetch" href="/netprotocol/assets/js/23.167adbf1.js"><link rel="prefetch" href="/netprotocol/assets/js/24.8900bbcf.js"><link rel="prefetch" href="/netprotocol/assets/js/25.330a47bc.js"><link rel="prefetch" href="/netprotocol/assets/js/26.ee198c03.js"><link rel="prefetch" href="/netprotocol/assets/js/27.49077d84.js"><link rel="prefetch" href="/netprotocol/assets/js/28.969912e2.js"><link rel="prefetch" href="/netprotocol/assets/js/29.0ab6db51.js"><link rel="prefetch" href="/netprotocol/assets/js/3.7da37368.js"><link rel="prefetch" href="/netprotocol/assets/js/30.f0f9e81e.js"><link rel="prefetch" href="/netprotocol/assets/js/31.b23a44cb.js"><link rel="prefetch" href="/netprotocol/assets/js/32.60bfb2fa.js"><link rel="prefetch" href="/netprotocol/assets/js/33.5f11c77a.js"><link rel="prefetch" href="/netprotocol/assets/js/34.89bbb6bb.js"><link rel="prefetch" href="/netprotocol/assets/js/35.1dd49070.js"><link rel="prefetch" href="/netprotocol/assets/js/36.f3bf019a.js"><link rel="prefetch" href="/netprotocol/assets/js/37.25799f73.js"><link rel="prefetch" href="/netprotocol/assets/js/38.3008dfdf.js"><link rel="prefetch" href="/netprotocol/assets/js/39.c71d98ea.js"><link rel="prefetch" href="/netprotocol/assets/js/4.a80811a8.js"><link rel="prefetch" href="/netprotocol/assets/js/40.659ae002.js"><link rel="prefetch" href="/netprotocol/assets/js/41.e8d258e6.js"><link rel="prefetch" href="/netprotocol/assets/js/42.97402baf.js"><link rel="prefetch" href="/netprotocol/assets/js/43.457f305d.js"><link rel="prefetch" href="/netprotocol/assets/js/44.6c2906f4.js"><link rel="prefetch" href="/netprotocol/assets/js/45.dfdf5a0e.js"><link rel="prefetch" href="/netprotocol/assets/js/46.8ead4a08.js"><link rel="prefetch" href="/netprotocol/assets/js/47.42ec58e7.js"><link rel="prefetch" href="/netprotocol/assets/js/48.c2d6747a.js"><link rel="prefetch" href="/netprotocol/assets/js/49.678b4eba.js"><link rel="prefetch" href="/netprotocol/assets/js/5.55ab3fc9.js"><link rel="prefetch" href="/netprotocol/assets/js/50.f1ad00b4.js"><link rel="prefetch" href="/netprotocol/assets/js/51.aa8a0c2d.js"><link rel="prefetch" href="/netprotocol/assets/js/52.ea53ee59.js"><link rel="prefetch" href="/netprotocol/assets/js/53.66bb194f.js"><link rel="prefetch" href="/netprotocol/assets/js/54.15d306c1.js"><link rel="prefetch" href="/netprotocol/assets/js/6.aeaee4ea.js"><link rel="prefetch" href="/netprotocol/assets/js/7.85695bf5.js"><link rel="prefetch" href="/netprotocol/assets/js/8.544243b8.js"><link rel="prefetch" href="/netprotocol/assets/js/9.4618c319.js">
    <link rel="stylesheet" href="/netprotocol/assets/css/0.styles.8ed81d4f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/netprotocol/" class="home-link router-link-active"><!----> <span class="site-name">趣谈网络协议</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/netprotocol/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他专栏</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/frontend/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  重学前端
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/ds/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  数据结构与算法之美
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/jvm/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入拆解 Java 虚拟机
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/air/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  左耳听风
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/blockchain/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入浅出区块链
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/netprotocol/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他专栏</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/frontend/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  重学前端
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/ds/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  数据结构与算法之美
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/jvm/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入拆解 Java 虚拟机
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/air/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  左耳听风
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://doc.mcust.cn/blockchain/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入浅出区块链
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/netprotocol/article/7398.html" class="sidebar-link">开篇词 | 想成为技术牛人？先搞定网络协议！</a></li><li><a href="/netprotocol/article/7581.html" class="sidebar-link">第1讲 | 为什么要学习网络协议？</a></li><li><a href="/netprotocol/article/7724.html" class="sidebar-link">第2讲 | 网络分层的真实含义是什么？</a></li><li><a href="/netprotocol/article/7772.html" class="sidebar-link">第3讲 | ifconfig：最熟悉又陌生的命令行</a></li><li><a href="/netprotocol/article/8015.html" class="sidebar-link">第4讲 | DHCP与PXE：IP是怎么来的，又是怎么没的？</a></li><li><a href="/netprotocol/article/8094.html" class="sidebar-link">第5讲 | 从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？</a></li><li><a href="/netprotocol/article/8386.html" class="sidebar-link">第6讲 | 交换机与VLAN：办公室太复杂，我要回学校</a></li><li><a href="/netprotocol/article/8445.html" class="sidebar-link">第7讲 | ICMP与ping：投石问路的侦察兵</a></li><li><a href="/netprotocol/article/8590.html" class="sidebar-link">第8讲 | 世界这么大，我想出网关：欧洲十国游与玄奘西行</a></li><li><a href="/netprotocol/article/8729.html" class="sidebar-link">第9讲 | 路由协议：西出网关无故人，敢问路在何方</a></li><li><a href="/netprotocol/article/8924.html" class="sidebar-link">第10讲 | UDP协议：因性善而简单，难免碰到“城会玩”</a></li><li><a href="/netprotocol/article/8975.html" class="sidebar-link">第11讲 | TCP协议（上）：因性恶而复杂，先恶后善反轻松</a></li><li><a href="/netprotocol/article/9141.html" class="sidebar-link">第12讲 | TCP协议（下）：西行必定多妖孽，恒心智慧消磨难</a></li><li><a href="/netprotocol/article/9293.html" class="sidebar-link">第13讲 | 套接字Socket：Talk is cheap, show me the code</a></li><li><a href="/netprotocol/article/9410.html" class="sidebar-link">第14讲 | HTTP协议：看个新闻原来这么麻烦</a></li><li><a href="/netprotocol/article/9492.html" class="sidebar-link">第15讲 | HTTPS协议：点外卖的过程原来这么复杂</a></li><li><a href="/netprotocol/article/9688.html" class="sidebar-link">第16讲 | 流媒体协议：如何在直播里看到美女帅哥？</a></li><li><a href="/netprotocol/article/9707.html" class="sidebar-link">第17讲 | P2P协议：我下小电影，99%急死你</a></li><li><a href="/netprotocol/article/9895.html" class="sidebar-link">第18讲 | DNS协议：网络世界的地址簿</a></li><li><a href="/netprotocol/article/9938.html" class="sidebar-link">第19讲 | HTTPDNS：网络世界的地址簿也会指错路</a></li><li><a href="/netprotocol/article/10085.html" class="sidebar-link">第20讲 | CDN：你去小卖部取过快递么？</a></li><li><a href="/netprotocol/article/10098.html" class="sidebar-link">第21讲 | 数据中心：我是开发商，自己拿地盖别墅</a></li><li><a href="/netprotocol/article/10386.html" class="sidebar-link">第22讲 | VPN：朝中有人好做官</a></li><li><a href="/netprotocol/article/10534.html" class="sidebar-link">第23讲 | 移动网络：去巴塞罗那，手机也上不了脸书</a></li><li><a href="/netprotocol/article/10742.html" class="sidebar-link">第24讲 | 云中网络：自己拿地成本高，购买公寓更灵活</a></li><li><a href="/netprotocol/article/10755.html" class="sidebar-link">第25讲 | 软件定义网络：共享基础设施的小区物业管理办法</a></li><li><a href="/netprotocol/article/10978.html" class="sidebar-link">第26讲 | 云中的网络安全：虽然不是土豪，也需要基本安全和保障</a></li><li><a href="/netprotocol/article/10994.html" class="sidebar-link">第27讲 | 云中的网络QoS：邻居疯狂下电影，我该怎么办？</a></li><li><a href="/netprotocol/article/11324.html" class="sidebar-link">第28讲 | 云中网络的隔离GRE、VXLAN：虽然住一个小区，也要保护隐私</a></li><li><a href="/netprotocol/article/11465.html" class="sidebar-link">第29讲 | 容器网络：来去自由的日子，不买公寓去合租</a></li><li><a href="/netprotocol/article/11643.html" class="sidebar-link">第30讲 | 容器网络之Flannel：每人一亩三分地</a></li><li><a href="/netprotocol/article/11940.html" class="active sidebar-link">第31讲 | 容器网络之Calico：为高效说出善意的谎言</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/netprotocol/article/11940.html#calico网络模型的设计思路" class="sidebar-link">Calico网络模型的设计思路</a></li><li class="sidebar-sub-header"><a href="/netprotocol/article/11940.html#calico网络的转发细节" class="sidebar-link">Calico网络的转发细节</a></li><li class="sidebar-sub-header"><a href="/netprotocol/article/11940.html#calico的架构" class="sidebar-link">Calico的架构</a></li><li class="sidebar-sub-header"><a href="/netprotocol/article/11940.html#全连接复杂性与规模问题" class="sidebar-link">全连接复杂性与规模问题</a></li><li class="sidebar-sub-header"><a href="/netprotocol/article/11940.html#跨网段访问问题" class="sidebar-link">跨网段访问问题</a></li><li class="sidebar-sub-header"><a href="/netprotocol/article/11940.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/netprotocol/article/12230.html" class="sidebar-link">第32讲 | RPC协议综述：远在天边，近在眼前</a></li><li><a href="/netprotocol/article/12388.html" class="sidebar-link">第33讲 | 基于XML的SOAP协议：不要说NBA，请说美国职业篮球联赛</a></li><li><a href="/netprotocol/article/12512.html" class="sidebar-link">第34讲 | 基于JSON的RESTful接口协议：我不关心过程，请给我结果</a></li><li><a href="/netprotocol/article/12521.html" class="sidebar-link">第35讲 | 二进制类RPC协议：还是叫NBA吧，总说全称多费劲</a></li><li><a href="/netprotocol/article/12819.html" class="sidebar-link">第36讲 | 跨语言类RPC协议：交流之前，双方先来个专业术语表</a></li><li><a href="/netprotocol/article/12991.html" class="sidebar-link">第37讲 | 知识串讲：用双十一的故事串起碎片的网络协议（上）</a></li><li><a href="/netprotocol/article/12996.html" class="sidebar-link">第38讲 | 知识串讲：用双十一的故事串起碎片的网络协议（中）</a></li><li><a href="/netprotocol/article/13099.html" class="sidebar-link">第39讲 | 知识串讲：用双十一的故事串起碎片的网络协议（下）</a></li><li><a href="/netprotocol/article/13124.html" class="sidebar-link">第40讲 | 搭建一个网络实验环境：授人以鱼不如授人以渔</a></li><li><a href="/netprotocol/article/13520.html" class="sidebar-link">协议专栏特别福利 | 答疑解惑第一期</a></li><li><a href="/netprotocol/article/13847.html" class="sidebar-link">协议专栏特别福利 | 答疑解惑第二期</a></li><li><a href="/netprotocol/article/14028.html" class="sidebar-link">协议专栏特别福利 | 答疑解惑第三期</a></li><li><a href="/netprotocol/article/14194.html" class="sidebar-link">协议专栏特别福利 | 答疑解惑第四期</a></li><li><a href="/netprotocol/article/14381.html" class="sidebar-link">协议专栏特别福利 | 答疑解惑第五期</a></li><li><a href="/netprotocol/article/14384.html" class="sidebar-link">测一测 | 这些网络协议你都掌握了吗？</a></li><li><a href="/netprotocol/article/14553.html" class="sidebar-link">结束语 | 放弃完美主义，执行力就是限时限量认真完成</a></li><li><a href="/netprotocol/article/17846.html" class="sidebar-link">我是如何创作“趣谈网络协议”专栏的？</a></li><li><a href="/netprotocol/article/17862.html" class="sidebar-link">“趣谈网络协议”专栏「食用指南」</a></li></ul> </div> <div class="page"> <div class="content"><p>上一节我们讲了Flannel如何解决容器跨主机互通的问题，这个解决方式其实和虚拟机的网络互通模式是差不多的，都是通过隧道。但是Flannel有一个非常好的模式，就是给不同的物理机设置不同网段，这一点和虚拟机的Overlay的模式完全不一样。</p> <p>在虚拟机的场景下，整个网段在所有的物理机之间都是可以“飘来飘去”的。网段不同，就给了我们做路由策略的可能。</p> <h2 id="calico网络模型的设计思路"><a href="#calico网络模型的设计思路" aria-hidden="true" class="header-anchor">#</a> Calico网络模型的设计思路</h2> <p>我们看图中的两台物理机。它们的物理网卡是同一个二层网络里面的。由于两台物理机的容器网段不同，我们完全可以将两台物理机配置成为路由器，并按照容器的网段配置路由表。</p> <p><img src="https://static001.geekbang.org/resource/image/1e/50/1e2420928488bdcf66ffd001393c3c50.jpg" alt></p> <p>例如，在物理机A中，我们可以这样配置：要想访问网段172.17.9.0/24，下一跳是192.168.100.101，也即到物理机B上去。</p> <p>这样在容器A中访问容器B，当包到达物理机A的时候，就能够匹配到这条路由规则，并将包发给下一跳的路由器，也即发给物理机B。在物理机B上也有路由规则，要访问172.17.9.0/24，从docker0的网卡进去即可。</p> <p>当容器B返回结果的时候，在物理机B上，可以做类似的配置：要想访问网段172.17.8.0/24，下一跳是192.168.100.100，也即到物理机A上去。</p> <p>当包到达物理机B的时候，能够匹配到这条路由规则，将包发给下一跳的路由器，也即发给物理机A。在物理机A上也有路由规则，要访问172.17.8.0/24，从docker0的网卡进去即可。</p> <p>这就是<strong>Calico网络的大概思路</strong>，<strong>即不走Overlay网络，不引入另外的网络性能损耗，而是将转发全部用三层网络的路由转发来实现</strong>，只不过具体的实现和上面的过程稍有区别。</p> <p>首先，如果全部走三层的路由规则，没必要每台机器都用一个docker0，从而浪费了一个IP地址，而是可以直接用路由转发到veth pair在物理机这一端的网卡。同样，在容器内，路由规则也可以这样设定：把容器外面的veth pair网卡算作默认网关，下一跳就是外面的物理机。</p> <p>于是，整个拓扑结构就变成了这个图中的样子。</p> <p><img src="https://static001.geekbang.org/resource/image/c3/9c/c3e999c033a0417df98c0bcc34c9349c.jpg" alt></p> <h2 id="calico网络的转发细节"><a href="#calico网络的转发细节" aria-hidden="true" class="header-anchor">#</a> Calico网络的转发细节</h2> <p>我们来看其中的一些细节。</p> <p>容器A1的IP地址为172.17.8.2/32，这里注意，不是/24，而是/32，将容器A1作为一个单点的局域网了。</p> <p>容器A1里面的默认路由，Calico配置得比较有技巧。</p> <pre><code>default via 169.254.1.1 dev eth0 
169.254.1.1 dev eth0 scope link 
</code></pre> <p>这个IP地址169.254.1.1是默认的网关，但是整个拓扑图中没有一张网卡是这个地址。那如何到达这个地址呢？</p> <p>前面我们讲网关的原理的时候说过，当一台机器要访问网关的时候，首先会通过ARP获得网关的MAC地址，然后将目标MAC变为网关的MAC，而网关的IP地址不会在任何网络包头里面出现，也就是说，没有人在乎这个地址具体是什么，只要能找到对应的MAC，响应ARP就可以了。</p> <p>ARP本地有缓存，通过ip neigh命令可以查看。</p> <pre><code>169.254.1.1 dev eth0 lladdr ee:ee:ee:ee:ee:ee STALE
</code></pre> <p>这个MAC地址是Calico硬塞进去的，但是没有关系，它能响应ARP，于是发出的包的目标MAC就是这个MAC地址。</p> <p>在物理机A上查看所有网卡的MAC地址的时候，我们会发现veth1就是这个MAC地址。所以容器A1里发出的网络包，第一跳就是这个veth1这个网卡，也就到达了物理机A这个路由器。</p> <p>在物理机A上有三条路由规则，分别是去两个本机的容器的路由，以及去172.17.9.0/24，下一跳为物理机B。</p> <pre><code>172.17.8.2 dev veth1 scope link 
172.17.8.3 dev veth2 scope link 
172.17.9.0/24 via 192.168.100.101 dev eth0 proto bird onlink
</code></pre> <p>同理，物理机B上也有三条路由规则，分别是去两个本机的容器的路由，以及去172.17.8.0/24，下一跳为物理机A。</p> <pre><code>172.17.9.2 dev veth1 scope link 
172.17.9.3 dev veth2 scope link 
172.17.8.0/24 via 192.168.100.100 dev eth0 proto bird onlink
</code></pre> <p>如果你觉得这些规则过于复杂，我将刚才的拓扑图转换为这个更加容易理解的图。</p> <p><img src="https://static001.geekbang.org/resource/image/e5/7d/e59559ad7b46b9811553b6b0a85e8e7d.jpg" alt></p> <p>在这里，物理机化身为路由器，通过路由器上的路由规则，将包转发到目的地。在这个过程中，没有隧道封装解封装，仅仅是单纯的路由转发，性能会好很多。但是，这种模式也有很多问题。</p> <h2 id="calico的架构"><a href="#calico的架构" aria-hidden="true" class="header-anchor">#</a> Calico的架构</h2> <h3 id="路由配置组件felix"><a href="#路由配置组件felix" aria-hidden="true" class="header-anchor">#</a> 路由配置组件Felix</h3> <p>如果只有两台机器，每台机器只有两个容器，而且保持不变。我手动配置一下，倒也没啥问题。但是如果容器不断地创建、删除，节点不断地加入、退出，情况就会变得非常复杂。</p> <p><img src="https://static001.geekbang.org/resource/image/f2/31/f29027cca71f3dfbba8c2f1a35c29331.jpg" alt></p> <p>就像图中，有三台物理机，两两之间都需要配置路由，每台物理机上对外的路由就有两条。如果有六台物理机，则每台物理机上对外的路由就有五条。新加入一个节点，需要通知每一台物理机添加一条路由。</p> <p>这还是在物理机之间，一台物理机上，每创建一个容器，也需要多配置一条指向这个容器的路由。如此复杂，肯定不能手动配置，需要每台物理机上有一个agent，当创建和删除容器的时候，自动做这件事情。这个agent在Calico中称为Felix。</p> <h3 id="路由广播组件bgp-speaker"><a href="#路由广播组件bgp-speaker" aria-hidden="true" class="header-anchor">#</a> 路由广播组件BGP Speaker</h3> <p>当Felix配置了路由之后，接下来的问题就是，如何将路由信息，也即将“如何到达我这个节点，访问我这个节点上的容器”这些信息，广播出去。</p> <p>能想起来吗？这其实就是路由协议啊！路由协议就是将“我能到哪里，如何能到我”的信息广播给全网传出去，从而客户端可以一跳一跳地访问目标地址的。路由协议有很多种，Calico使用的是BGP协议。</p> <p>在Calico中，每个Node上运行一个软件BIRD，作为BGP的客户端，或者叫作BGP Speaker，将“如何到达我这个Node，访问我这个Node上的容器”的路由信息广播出去。所有Node上的BGP Speaker 都互相建立连接，就形成了全互连的情况，这样每当路由有所变化的时候，所有节点就都能够收到了。</p> <h3 id="安全策略组件"><a href="#安全策略组件" aria-hidden="true" class="header-anchor">#</a> 安全策略组件</h3> <p>Calico中还实现了灵活配置网络策略Network Policy，可以灵活配置两个容器通或者不通。这个怎么实现呢？</p> <p><img src="https://static001.geekbang.org/resource/image/1a/17/1a0ba797b9a0f0e32c9e561b97955917.jpg" alt></p> <p>虚拟机中的安全组，是用iptables实现的。Calico中也是用iptables实现的。这个图里的内容是iptables在内核处理网络包的过程中可以嵌入的处理点。Calico也是在这些点上设置相应的规则。</p> <p><img src="https://static001.geekbang.org/resource/image/d2/15/d27a1bf22f9b70696ca13abb6a655d15.jpg" alt></p> <p>当网络包进入物理机上的时候，进入PREOUTING规则，这里面有一个规则是cali-fip-dnat，这是实现浮动IP（Floating IP）的场景，主要将外网的IP地址dnat为容器内的IP地址。在虚拟机场景下，路由器的网络namespace里面有一个外网网卡上，也设置过这样一个DNAT规则。</p> <p>接下来可以根据路由判断，是到本地的，还是要转发出去的。</p> <p>如果是本地的，走INPUT规则，里面有个规则是cali-wl-to-host，wl的意思是workload，也即容器，也即这是用来判断从容器发到物理机的网络包是否符合规则的。这里面内嵌一个规则cali-from-wl-dispatch，也是匹配从容器来的包。如果有两个容器，则会有两个容器网卡，这里面内嵌有详细的规则“cali-fw-cali网卡1”和“cali-fw-cali网卡2”，fw就是from workload，也就是匹配从容器1来的网络包和从容器2来的网络包。</p> <p>如果是转发出去的，走FORWARD规则，里面有个规则cali-FORWARD。这里面分两种情况，一种是从容器里面发出来，转发到外面的；另一种是从外面发进来，转发到容器里面的。</p> <p>第一种情况匹配的规则仍然是cali-from-wl-dispatch，也即from workload。第二种情况匹配的规则是cali-to-wl-dispatch，也即to workload。如果有两个容器，则会有两个容器网卡，在这里面内嵌有详细的规则“cali-tw-cali网卡1”和“cali-tw-cali网卡2”，tw就是to workload，也就是匹配发往容器1的网络包和发送到容器2的网络包。</p> <p>接下来是匹配OUTPUT规则，里面有cali-OUTPUT。接下来是POSTROUTING规则，里面有一个规则是cali-fip-snat，也即发出去的时候，将容器网络IP转换为浮动IP地址。在虚拟机场景下，路由器的网络namespace里面有一个外网网卡上，也设置过这样一个SNAT规则。</p> <p>至此为止，Calico的所有组件基本凑齐。来看看我汇总的图。</p> <p><img src="https://static001.geekbang.org/resource/image/df/b2/df8d92d84af55369055738283339d6b2.jpg" alt></p> <h2 id="全连接复杂性与规模问题"><a href="#全连接复杂性与规模问题" aria-hidden="true" class="header-anchor">#</a> 全连接复杂性与规模问题</h2> <p>这里面还存在问题，就是BGP全连接的复杂性问题。</p> <p>你看刚才的例子里只有六个节点，BGP的互连已经如此复杂，如果节点数据再多，这种全互连的模式肯定不行，到时候都成蜘蛛网了。于是多出了一个组件BGP Route Reflector，它也是用BIRD实现的。有了它，BGP Speaker就不用全互连了，而是都直连它，它负责将全网的路由信息广播出去。</p> <p>可是问题来了，规模大了，大家都连它，它受得了吗？这个BGP Router Reflector会不会成为瓶颈呢？</p> <p>所以，肯定不能让一个BGP Router Reflector管理所有的路由分发，而是应该有多个BGP Router Reflector，每个BGP Router Reflector管一部分。</p> <p>多大算一部分呢？咱们讲述数据中心的时候，说服务器都是放在机架上的，每个机架上最顶端有个TOR交换机。那将机架上的机器连在一起，这样一个机架是不是可以作为一个单元，让一个BGP Router Reflector来管理呢？如果要跨机架，如何进行通信呢？这就需要BGP Router Reflector也直接进行路由交换。它们之间的交换和一个机架之间的交换有什么关系吗？</p> <p>有没有觉得在这个场景下，一个机架就像一个数据中心，可以把它设置为一个AS，而BGP Router Reflector有点儿像数据中心的边界路由器。在一个AS内部，也即服务器和BGP Router Reflector之间使用的是数据中心内部的路由协议iBGP，BGP Router Reflector之间使用的是数据中心之间的路由协议eBGP。</p> <p><img src="https://static001.geekbang.org/resource/image/f7/ff/f7e9467901ccb4b7e8039c53314244ff.jpg" alt></p> <p>这个图中，一个机架上有多台机器，每台机器上面启动多个容器，每台机器上都有可以到达这些容器的路由。每台机器上都启动一个BGP Speaker，然后将这些路由规则上报到这个Rack上接入交换机的BGP Route Reflector，将这些路由通过iBGP协议告知到接入交换机的三层路由功能。</p> <p>在接入交换机之间也建立BGP连接，相互告知路由，因而一个Rack里面的路由可以告知另一个Rack。有多个核心或者汇聚交换机将接入交换机连接起来，如果核心和汇聚起二层互通的作用，则接入和接入之间之间交换路由即可。如果核心和汇聚交换机起三层路由的作用，则路由需要通过核心或者汇聚交换机进行告知。</p> <h2 id="跨网段访问问题"><a href="#跨网段访问问题" aria-hidden="true" class="header-anchor">#</a> 跨网段访问问题</h2> <p>上面的Calico模式还有一个问题，就是跨网段问题，这里的跨网段是指物理机跨网段。</p> <p>前面我们说的那些逻辑成立的条件，是我们假设物理机可以作为路由器进行使用。例如物理机A要告诉物理机B，你要访问172.17.8.0/24，下一跳是我192.168.100.100；同理，物理机B要告诉物理机A，你要访问172.17.9.0/24，下一跳是我192.168.100.101。</p> <p>之所以能够这样，是因为物理机A和物理机B是同一个网段的，是连接在同一个交换机上的。那如果物理机A和物理机B不是在同一个网段呢？</p> <p><img src="https://static001.geekbang.org/resource/image/88/84/88a1817b32c3c364fbbdf50b05d49e84.jpg" alt></p> <p>例如，物理机A的网段是192.168.100.100/24，物理机B的网段是192.168.200.101/24，这样两台机器就不能通过二层交换机连接起来了，需要在中间放一台路由器，做一次路由转发，才能跨网段访问。</p> <p>本来物理机A要告诉物理机B，你要访问172.17.8.0/24，下一跳是我192.168.100.100的，但是中间多了一台路由器，下一跳不是我了，而是中间的这台路由器了，这台路由器的再下一跳，才是我。这样之前的逻辑就不成立了。</p> <p>我们看刚才那张图的下半部分。物理机B上的容器要访问物理机A上的容器，第一跳就是物理机B，IP为192.168.200.101，第二跳是中间的物理路由器右面的网口，IP为192.168.200.1，第三跳才是物理机A，IP为192.168.100.100。</p> <p>这是咱们通过拓扑图看到的，关键问题是，在系统中物理机A如何告诉物理机B，怎么让它才能到我这里？物理机A根本不可能知道从物理机B出来之后的下一跳是谁，况且现在只是中间隔着一个路由器这种简单的情况，如果隔着多个路由器呢？谁能把这一串的路径告诉物理机B呢？</p> <p>我们能想到的第一种方式是，让中间所有的路由器都来适配Calico。本来它们互相告知路由，只互相告知物理机的，现在还要告知容器的网段。这在大部分情况下，是不可能的。</p> <p>第二种方式，还是在物理机A和物理机B之间打一个隧道，这个隧道有两个端点，在端点上进行封装，将容器的IP作为乘客协议放在隧道里面，而物理主机的IP放在外面作为承载协议。这样不管外层的IP通过传统的物理网络，走多少跳到达目标物理机，从隧道两端看起来，物理机A的下一跳就是物理机B，这样前面的逻辑才能成立。</p> <p>这就是Calico的<strong>IPIP模式</strong>。使用了IPIP模式之后，在物理机A上，我们能看到这样的路由表：</p> <pre><code>172.17.8.2 dev veth1 scope link 
172.17.8.3 dev veth2 scope link 
172.17.9.0/24 via 192.168.200.101 dev tun0 proto bird onlink
</code></pre> <p>这和原来模式的区别在于，下一跳不再是同一个网段的物理机B了，IP为192.168.200.101，并且不是从eth0跳，而是建立一个隧道的端点tun0，从这里才是下一跳。</p> <p>如果我们在容器A1里面的172.17.8.2，去ping容器B1里面的172.17.9.2，首先会到物理机A。在物理机A上根据上面的规则，会转发给tun0，并在这里对包做封装：</p> <ul><li><p>内层源IP为172.17.8.2；</p></li> <li><p>内层目标IP为172.17.9.2；</p></li> <li><p>外层源IP为192.168.100.100；</p></li> <li><p>外层目标IP为192.168.200.101。</p></li></ul> <p>将这个包从eth0发出去，在物理网络上会使用外层的IP进行路由，最终到达物理机B。在物理机B上，tun0会解封装，将内层的源IP和目标IP拿出来，转发给相应的容器。</p> <h2 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> 小结</h2> <p>好了，这一节就到这里，我们来总结一下。</p> <ul><li><p>Calico推荐使用物理机作为路由器的模式，这种模式没有虚拟化开销，性能比较高。</p></li> <li><p>Calico的主要组件包括路由、iptables的配置组件Felix、路由广播组件BGP Speaker，以及大规模场景下的BGP Route Reflector。</p></li> <li><p>为解决跨网段的问题，Calico还有一种IPIP模式，也即通过打隧道的方式，从隧道端点来看，将本来不是邻居的两台机器，变成相邻的机器。</p></li></ul> <p>最后，给你留两个思考题：</p> <ol><li><p>将Calico部署在公有云上的时候，经常会选择使用IPIP模式，你知道这是为什么吗？</p></li> <li><p>容器是用来部署微服务的，微服务之间的通信，除了网络要互通，还需要高效的传输信息，例如下单的商品、价格、数量、支付的钱等等，这些要通过什么样的协议呢？</p></li></ol> <p>我们的专栏更新到第31讲，不知你掌握得如何？每节课后我留的思考题，你都有没有认真思考，并在留言区写下答案呢？我会从<strong>已发布的文章中选出一批认真留言的同学</strong>，赠送学习奖励礼券和我整理的独家网络协议知识图谱。</p> <p>欢迎你留言和我讨论。趣谈网络协议，我们下期见！</p> <p><img src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg" alt></p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/netprotocol/article/11643.html" class="prev">
          第30讲 | 容器网络之Flannel：每人一亩三分地
        </a></span> <span class="next"><a href="/netprotocol/article/12230.html">
          第32讲 | RPC协议综述：远在天边，近在眼前
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/netprotocol/assets/js/app.a42fbc22.js" defer></script><script src="/netprotocol/assets/js/15.bba6998c.js" defer></script>
  </body>
</html>
