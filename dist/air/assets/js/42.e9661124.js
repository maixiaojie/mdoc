(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{263:function(e,n,t){"use strict";t.r(n);var r=t(0),o=Object(r.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("p",[e._v("在上一篇文章中，我们领略了函数式编程的趣味和魅力，主要讲了函数式编程的主要技术。还记得有哪些吗？递归、Map、Reduce、Filter等，并利用Python的Decorator和Generator功能，将多个函数组合成了管道。")]),e._v(" "),t("p",[e._v("此时，你心中可能会有个疑问，这个decorator又是怎样工作的呢？这就是本文中要讲述的内容，“Decorator模式”，又叫“修饰器模式”，或是“装饰器模式”。")]),e._v(" "),e._m(0),e._v(" "),t("p",[e._v("Python的Decorator在使用上和Java的Annotation（以及C#的Attribute）很相似，就是在方法名前面加一个@XXX注解来为这个方法装饰一些东西。但是，Java/C#的Annotation也很让人望而却步，太过于复杂了。你要玩它，需要先了解一堆Annotation的类库文档，感觉几乎就是在学另外一门语言。")]),e._v(" "),t("p",[e._v("而Python使用了一种相对于Decorator Pattern和Annotation来说非常优雅的方法，这种方法不需要你去掌握什么复杂的OO模型或是Annotation的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。")]),e._v(" "),t("p",[e._v("这是我最喜欢的一个模式了，也是一个挺好玩儿的东西，这个模式动用了函数式编程的一个技术——用一个函数来构造另一个函数。")]),e._v(" "),t("p",[e._v("好了，我们先来点感性认识，看一个Python修饰器的Hello World代码。")]),e._v(" "),e._m(1),e._v(" "),t("p",[e._v("代码的执行结果如下：")]),e._v(" "),e._m(2),e._v(" "),t("p",[e._v("你可以看到如下的东西：")]),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),t("p",[e._v("其解释器会解释成下面这样的语句：")]),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),t("p",[e._v("我们再来看一个带参数的玩法：")]),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),t("p",[e._v("我们再来看一个为其它函数加缓存的示例:")]),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),t("p",[e._v("除此之外，Python还支持类方式的decorator。")]),e._v(" "),e._m(14),e._v(" "),t("p",[e._v("上面这个示例展示了，用类的方式声明一个decorator。我们可以看到这个类中有两个成员：")]),e._v(" "),e._m(15),e._v(" "),t("p",[e._v("从上面的输出中，可以看到整个程序的执行顺序。这看上去要比“函数式”的方式更易读一些。")]),e._v(" "),t("p",[e._v("我们来看一个实际点的例子。下面这个示例展示了通过URL的路由来调用相关注册的函数示例：")]),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),t("p",[e._v("Python有语法糖，所以写出来的代码比较酷。但是对于没有修饰器语法糖这类语言，写出来的代码会是怎么样的？我们来看一下Go语言的代码。")]),e._v(" "),t("p",[e._v("还是从一个Hello World开始。")]),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),t("p",[e._v("这个玩法和Python的异曲同工，只不过，Go并不支持像Python那样的@decorator语法糖。所以，在调用上有些难看。当然，如果要想让代码容易读一些，你可以这样：")]),e._v(" "),e._m(21),e._v(" "),t("p",[e._v("我们再来看一个为函数log消耗时间的例子：")]),e._v(" "),e._m(22),e._v(" "),t("p",[e._v("关于上面的代码：")]),e._v(" "),e._m(23),e._v(" "),t("p",[e._v("再来看一个 HTTP 路由的例子：")]),e._v(" "),e._m(24),e._v(" "),t("p",[e._v("上面的代码中，我们写了多个函数。有写HTTP响应头的，有写认证Cookie的，有检查认证Cookie的，有打日志的……在使用过程中，我们可以把其嵌套起来使用，在修饰过的函数上继续修饰，这样就可以拼装出更复杂的功能。")]),e._v(" "),e._m(25),e._v(" "),t("p",[e._v("当然，如果一层套一层不好看的话，我们可以使用pipeline的玩法——我们需要先写一个工具函数——用来遍历并调用各个decorator：")]),e._v(" "),e._m(26),e._v(" "),t("p",[e._v("然后，我们就可以像下面这样使用了。")]),e._v(" "),e._m(27),e._v(" "),t("p",[e._v("这样的代码是不是更易读了一些？pipeline的功能也就出来了。")]),e._v(" "),t("p",[e._v("不过，对于Go的修饰器模式，还有一个小问题——好像无法做到泛型，就像上面那个计算时间的函数一样，它的代码耦合了需要被修饰的函数的接口类型，无法做到非常通用。如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。")]),e._v(" "),t("p",[e._v("因为Go语言不像Python和Java，Python是动态语言，而Java有语言虚拟机，所以它们可以干许多比较变态的事儿，然而Go语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go语言支持的最大的泛型是interface{}，还有比较简单的reflection机制，在上面做做文章，应该还是可以搞定的。")]),e._v(" "),t("p",[e._v("废话不说，下面是我用reflection机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）。")]),e._v(" "),e._m(28),e._v(" "),t("p",[e._v("上面的代码动用了 "),t("code",[e._v("reflect.MakeFunc()")]),e._v(" 函数制作出了一个新的函数。其中的 "),t("code",[e._v("targetFunc.Call(in)")]),e._v(" 调用了被修饰的函数。关于Go语言的反射机制，推荐官方文章——《"),t("a",{attrs:{href:"https://blog.golang.org/laws-of-reflection",target:"_blank",rel:"noopener noreferrer"}},[e._v("The Laws of Reflection"),t("OutboundLink")],1),e._v("》，在这里我不多说了。")]),e._v(" "),e._m(29),e._v(" "),e._m(30),e._v(" "),t("p",[e._v("这样写是不是有些二？的确是的。不过，这是我个人在Go语言里所能写出来的最好的代码了。如果你知道更优雅的写法，请你一定告诉我！")]),e._v(" "),t("p",[e._v("好的，让我们来看一下使用效果。首先，假设我们有两个需要修饰的函数：")]),e._v(" "),e._m(31),e._v(" "),t("p",[e._v("然后，我们可以这样做：")]),e._v(" "),e._m(32),e._v(" "),e._m(33),e._v(" "),t("p",[e._v("嗯。如果你不想声明函数签名，那么也可以这样：")]),e._v(" "),e._m(34),e._v(" "),t("p",[e._v("好吧，看上去不是那么的漂亮，但是it does work。看样子Go语言目前本身的特性无法做成像Java或Python那样，对此，我们只能多求Go语言多放糖了！")]),e._v(" "),e._m(35),e._v(" "),t("p",[e._v("好了，讲了那么多的例子，看了那么多的代码，我估计你可能有点晕，让我们来做个小结吧。")]),e._v(" "),t("p",[e._v("通过上面Python和Go修饰器的例子，我们可以看到，所谓的修饰器模式其实是在做下面的几件事。")]),e._v(" "),e._m(36),e._v(" "),e._m(37),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/301",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（1）- 起源"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/303",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（2）- 泛型编程"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2017",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（3）- 类型系统和泛型的本质"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2711",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（4）- 函数式编程"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2723",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（5）- 修饰器模式"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2729",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（6）- 面向对象编程"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2741",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（7）- 基于原型的编程范式"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2748",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（8）- Go 语言的委托模式"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2751",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（9）- 编程的本质"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2752",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（10）- 逻辑编程范式"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/2754",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程范式游记（11）- 程序世界里的编程范式"),t("OutboundLink")],1)])]),e._v(" "),e._m(38)])},[function(){var e=this.$createElement,n=this._self._c||e;return n("h1",{attrs:{id:"python的decorator"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#python的decorator","aria-hidden":"true"}},[this._v("#")]),this._v(" Python的Decorator")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('def hello(fn):\n    def wrapper():\n        print "hello, %s" % fn.__name__\n        fn()\n        print "goodbye, %s" % fn.__name__\n    return wrapper\n \n@hello\ndef Hao():\n    print "i am Hao Chen"\n \nHao()\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("$ python hello.py\nhello, Hao\ni am Hao Chen\ngoodbye, Hao\n")])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ol",[t("li",[t("p",[e._v("函数 "),t("code",[e._v("Hao")]),e._v(" 前面有个@hello的“注解”，"),t("code",[e._v("hello")]),e._v(" 就是我们前面定义的函数 "),t("code",[e._v("hello")]),e._v("；")])]),e._v(" "),t("li",[t("p",[e._v("在 "),t("code",[e._v("hello")]),e._v(" 函数中，其需要一个 "),t("code",[e._v("fn")]),e._v(" 的参数（这就是用来做回调的函数）；")])]),e._v(" "),t("li",[t("p",[e._v("hello函数中返回了一个inner函数 "),t("code",[e._v("wrapper")]),e._v("，这个 "),t("code",[e._v("wrapper")]),e._v("函数回调了传进来的 "),t("code",[e._v("fn")]),e._v("，并在回调前后加了两条语句。")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("对于Python的这个@注解语法糖（syntactic sugar）来说，当你在用某个@decorator来修饰某个函数 "),n("code",[this._v("func")]),this._v(" 时，如下所示:")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("@decorator\ndef func():\n    pass\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("func = decorator(func)\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("嘿！这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的。但是，我们需要注意，那里还有一个赋值语句，把decorator这个函数的返回值赋值回了原来的 "),n("code",[this._v("func")]),this._v("。")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('def makeHtmlTag(tag, *args, **kwds):\n    def real_decorator(fn):\n        css_class = " class=\'{0}\'".format(kwds["css_class"]) \\\n                                     if "css_class" in kwds else ""\n        def wrapped(*args, **kwds):\n            return "<"+tag+css_class+">" + fn(*args, **kwds) + "</"+tag+">"\n        return wrapped\n    return real_decorator\n \n@makeHtmlTag(tag="b", css_class="bold_css")\n@makeHtmlTag(tag="i", css_class="italic_css")\ndef hello():\n    return "hello world"\n \nprint hello()\n \n# 输出：\n# <b class=\'bold_css\'><i class=\'italic_css\'>hello world</i></b>\n')])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("p",[e._v("在上面这个例子中，我们可以看到："),t("code",[e._v("makeHtmlTag")]),e._v("有两个参数。所以，为了让 "),t("code",[e._v("hello = makeHtmlTag(arg1, arg2)(hello)")]),e._v(" 成功， "),t("code",[e._v("makeHtmlTag")]),e._v(" 必需返回一个decorator（这就是为什么我们在 "),t("code",[e._v("makeHtmlTag")]),e._v(" 中加入了 "),t("code",[e._v("real_decorator()")]),e._v("）。")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("这样一来，我们就可以进入到decorator的逻辑中去了——decorator得返回一个wrapper，wrapper里回调 "),n("code",[this._v("hello")]),this._v("。看似那个 "),n("code",[this._v("makeHtmlTag()")]),this._v(" 写得层层叠叠，但是，已经了解了本质的我们觉得写得很自然。")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("from functools import wraps\ndef memoization(fn):\n    cache = {}\n    miss = object()\n \n    @wraps(fn)\n    def wrapper(*args):\n        result = cache.get(args, miss)\n        if result is miss:\n            result = fn(*args)\n            cache[args] = result\n        return result\n \n    return wrapper\n \n@memoization\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n")])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("p",[e._v("上面这个例子中，是一个斐波那契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成 "),t("code",[e._v("fib(4) + fib(3)")]),e._v("，而 "),t("code",[e._v("fib(4)")]),e._v(" 分解成 "),t("code",[e._v("fib(3) + fib(2)")]),e._v("，"),t("code",[e._v("fib(3)")]),e._v(" 又分解成"),t("code",[e._v("fib(2) + fib(1)")]),e._v("……你可以看到，基本上来说，"),t("code",[e._v("fib(3)")]),e._v(", "),t("code",[e._v("fib(2)")]),e._v(", "),t("code",[e._v("fib(1)")]),e._v("在整个递归过程中被调用了至少两次。")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("而我们用decorator，在调用函数前查询一下缓存，如果没有才调用，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。"),n("code",[this._v("wraps")]),this._v(" 的作用是保证 "),n("code",[this._v("fib")]),this._v(" 的函数名不被 "),n("code",[this._v("wrapper")]),this._v(" 所取代。")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('class myDecorator(object):\n    def __init__(self, fn):\n        print "inside myDecorator.__init__()"\n        self.fn = fn\n \n    def __call__(self):\n        self.fn()\n        print "inside myDecorator.__call__()"\n \n@myDecorator\ndef aFunction():\n    print "inside aFunction()"\n \nprint "Finished decorating aFunction()"\n \naFunction()\n \n# 输出：\n# inside myDecorator.__init__()\n# Finished decorating aFunction()\n# inside aFunction()\n# inside myDecorator.__call__()\n')])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ol",[t("li",[e._v("一个是"),t("code",[e._v("__init__()")]),e._v("，这个方法是在我们给某个函数decorate时被调用，所以，需要有一个 "),t("code",[e._v("fn")]),e._v(" 的参数，也就是被decorate的函数。")]),e._v(" "),t("li",[e._v("一个是"),t("code",[e._v("__call__()")]),e._v("，这个方法是在我们调用被decorate的函数时被调用的。")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("class MyApp():\n    def __init__(self):\n        self.func_map = {}\n \n    def register(self, name):\n        def func_wrapper(func):\n            self.func_map[name] = func\n            return func\n        return func_wrapper\n \n    def call_method(self, name=None):\n        func = self.func_map.get(name, None)\n        if func is None:\n            raise Exception(\"No function registered against - \" + str(name))\n        return func()\n \napp = MyApp()\n \n@app.register('/')\ndef main_page_func():\n    return \"This is the main page.\"\n \n@app.register('/next_page')\ndef next_page_func():\n    return \"This is the next page.\"\n \nprint app.call_method('/')\nprint app.call_method('/next_page')\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("注意：上面这个示例中decorator类不是真正的decorator，其中也没有"),n("code",[this._v("__call__()")]),this._v("，并且，wrapper返回了原函数。所以，原函数没有发生任何变化。")])},function(){var e=this.$createElement,n=this._self._c||e;return n("h1",{attrs:{id:"go语言的decorator"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#go语言的decorator","aria-hidden":"true"}},[this._v("#")]),this._v(" Go语言的Decorator")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('package main\n\nimport "fmt"\n\nfunc decorator(f func(s string)) func(s string) {\n    return func(s string) {\n        fmt.Println("Started")\n        f(s)\n        fmt.Println("Done")\n    }\n}\n\nfunc Hello(s string) {\n    fmt.Println(s)\n}\n\nfunc main() {\n    decorator(Hello)("Hello, World!")\n}\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("可以看到，我们动用了一个高阶函数 "),n("code",[this._v("decorator()")]),this._v("，在调用的时候，先把 "),n("code",[this._v("Hello()")]),this._v(" 函数传进去，然后其返回一个匿名函数。这个匿名函数中除了运行了自己的代码，也调用了被传入的 "),n("code",[this._v("Hello()")]),this._v(" 函数。")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('hello := decorator(Hello)\nhello("Hello")\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('type SumFunc func(int64, int64) int64\n\nfunc getFunctionName(i interface{}) string {\n    return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()\n}\n\nfunc timedSumFunc(f SumFunc) SumFunc {\n    return func(start, end int64) int64 {\n        defer func(t time.Time) {\n            fmt.Printf("--- Time Elapsed (%s): %v ---\\n", \n                getFunctionName(f), time.Since(t))\n        }(time.Now())\n        return f(start, end)\n    }\n}\n\nfunc Sum1(start, end int64) int64 {\n    var sum int64\n    sum = 0\n    if start > end {\n        start, end = end, start\n    }\n    for i := start; i <= end; i++ {\n        sum += i\n    }\n    return sum\n}\n\nfunc Sum2(start, end int64) int64 {\n    if start > end {\n        start, end = end, start\n    }\n    return (end - start + 1) * (end + start) / 2\n}\n\nfunc main() {\n\n    sum1 := timedSumFunc(Sum1)\n    sum2 := timedSumFunc(Sum2)\n\n    fmt.Printf("%d, %d\\n", sum1(-10000, 10000000), sum2(-10000, 10000000))\n}\n')])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ul",[t("li",[t("p",[e._v("有两个 Sum 函数，"),t("code",[e._v("Sum1()")]),e._v(" 函数就是简单地做个循环，"),t("code",[e._v("Sum2()")]),e._v(" 函数动用了数据公式。（注意："),t("code",[e._v("start")]),e._v(" 和 "),t("code",[e._v("end")]),e._v(" 有可能有负数的情况。）")])]),e._v(" "),t("li",[t("p",[e._v("代码中使用了Go语言的反射机制来获取函数名。")])]),e._v(" "),t("li",[t("p",[e._v("修饰器函数是 "),t("code",[e._v("timedSumFunc()")]),e._v("。")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println("---\x3eWithServerHeader()")\n        w.Header().Set("Server", "HelloServer v0.0.1")\n        h(w, r)\n    }\n}\n \nfunc WithAuthCookie(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println("---\x3eWithAuthCookie()")\n        cookie := &http.Cookie{Name: "Auth", Value: "Pass", Path: "/"}\n        http.SetCookie(w, cookie)\n        h(w, r)\n    }\n}\n \nfunc WithBasicAuth(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println("---\x3eWithBasicAuth()")\n        cookie, err := r.Cookie("Auth")\n        if err != nil || cookie.Value != "Pass" {\n            w.WriteHeader(http.StatusForbidden)\n            return\n        }\n        h(w, r)\n    }\n}\n \nfunc WithDebugLog(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println("---\x3eWithDebugLog")\n        r.ParseForm()\n        log.Println(r.Form)\n        log.Println("path", r.URL.Path)\n        log.Println("scheme", r.URL.Scheme)\n        log.Println(r.Form["url_long"])\n        for k, v := range r.Form {\n            log.Println("key:", k)\n            log.Println("val:", strings.Join(v, ""))\n        }\n        h(w, r)\n    }\n}\nfunc hello(w http.ResponseWriter, r *http.Request) {\n    log.Printf("Received Request %s from %s\\n", r.URL.Path, r.RemoteAddr)\n    fmt.Fprintf(w, "Hello, World! "+r.URL.Path)\n}\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('func main() {\n    http.HandleFunc("/v1/hello", WithServerHeader(WithAuthCookie(hello)))\n    http.HandleFunc("/v2/hello", WithServerHeader(WithBasicAuth(hello)))\n    http.HandleFunc("/v3/hello", WithServerHeader(WithBasicAuth(WithDebugLog(hello))))\n    err := http.ListenAndServe(":8080", nil)\n    if err != nil {\n        log.Fatal("ListenAndServe: ", err)\n    }\n}\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc\n \nfunc Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {\n    for i := range decors {\n        d := decors[len(decors)-1-i] // iterate in reverse\n        h = d(h)\n    }\n    return h\n}\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('http.HandleFunc("/v4/hello", Handler(hello,\n                WithServerHeader, WithBasicAuth, WithDebugLog))\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('func Decorator(decoPtr, fn interface{}) (err error) {\n    var decoratedFunc, targetFunc reflect.Value\n \n    decoratedFunc = reflect.ValueOf(decoPtr).Elem()\n    targetFunc = reflect.ValueOf(fn)\n \n    v := reflect.MakeFunc(targetFunc.Type(),\n        func(in []reflect.Value) (out []reflect.Value) {\n            fmt.Println("before")\n            out = targetFunc.Call(in)\n            fmt.Println("after")\n            return\n        })\n \n    decoratedFunc.Set(v)\n    return\n}\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("上面这个 "),n("code",[this._v("Decorator()")]),this._v(" 需要两个参数：")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ul",[n("li",[this._v("第一个是出参 "),n("code",[this._v("decoPtr")]),this._v(" ，就是完成修饰后的函数。")]),this._v(" "),n("li",[this._v("第二个是入参 "),n("code",[this._v("fn")]),this._v(" ，就是需要修饰的函数。")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('func foo(a, b, c int) int {\n    fmt.Printf("%d, %d, %d \\n", a, b, c)\n    return a + b + c\n}\n \nfunc bar(a, b string) string {\n    fmt.Printf("%s, %s \\n", a, b)\n    return a + b\n}\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v("type MyFoo func(int, int, int) int\nvar myfoo MyFoo\nDecorator(&myfoo, foo)\nmyfoo(1, 2, 3)\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("你会发现，使用 "),n("code",[this._v("Decorator()")]),this._v(" 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？谁叫这是有类型的静态编译的语言呢？")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",[this._v('mybar := bar\nDecorator(&mybar, bar)\nmybar("hello,", "world!")\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("h1",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[this._v("#")]),this._v(" 小结")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ul",[n("li",[n("p",[this._v("表面上看，修饰器模式就是扩展现有的一个函数的功能，让它可以干一些其他的事，或是在现有的函数功能上再附加上一些别的功能。")])]),this._v(" "),n("li",[n("p",[this._v("除了我们可以感受到"),n("strong",[this._v("函数式编程")]),this._v("下的代码扩展能力，我们还能感受到函数的互相和随意拼装带来的好处。")])]),this._v(" "),n("li",[n("p",[this._v("但是深入一下，我们不难发现，Decorator这个函数其实是可以修饰几乎所有的函数的。于是，这种可以通用于其它函数的编程方式，可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来（所谓的控制类型的代码就是像for-loop，或是打日志，或是函数路由，或是求函数运行时间之类的非业务功能性的代码）。")])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。"),n("strong",[this._v("这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[n("img",{attrs:{src:"https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg",alt:""}})])}],!1,null,null,null);n.default=o.exports}}]);